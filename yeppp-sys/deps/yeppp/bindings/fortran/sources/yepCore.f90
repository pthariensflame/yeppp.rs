!                       Yeppp! library implementation
!                   This file is auto-generated by Peach-Py,
!        Portable Efficient Assembly Code-generator in Higher-level Python,
!                  part of the Yeppp! library infrastructure
! This file is part of Yeppp! library and licensed under the New BSD license.
! See LICENSE.txt for the full text of the license.

!> @defgroup yepCore yepCore: basic arithmetic operations.
MODULE yepCore
    INTERFACE
        !> @ingroup yepCore
        !! @defgroup yepCore_Add	Addition

        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 8-bit integer arrays. Produces an array of signed 8-bit integer elements.
        !! @param[in]	x	The first addend array of signed 8-bit integer elements.
        !! @param[in]	y	The second addend array of signed 8-bit integer elements.
        !! @param[out]	sum	The summand array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V8sV8s_V8s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V8sV8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V8sV8s_V8s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 8-bit integer arrays. Produces an array of signed 16-bit integer elements.
        !! @param[in]	x	The first addend array of signed 8-bit integer elements.
        !! @param[in]	y	The second addend array of signed 8-bit integer elements.
        !! @param[out]	sum	The summand array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V8sV8s_V16s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V8sV8s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V8sV8s_V16s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two unsigned 8-bit integer arrays. Produces an array of unsigned 16-bit integer elements.
        !! @param[in]	x	The first addend array of unsigned 8-bit integer elements.
        !! @param[in]	y	The second addend array of unsigned 8-bit integer elements.
        !! @param[out]	sum	The summand array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V8uV8u_V16u & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V8uV8u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V8uV8u_V16u
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 16-bit integer arrays. Produces an array of signed 16-bit integer elements.
        !! @param[in]	x	The first addend array of signed 16-bit integer elements.
        !! @param[in]	y	The second addend array of signed 16-bit integer elements.
        !! @param[out]	sum	The summand array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V16sV16s_V16s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V16sV16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V16sV16s_V16s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 16-bit integer arrays. Produces an array of signed 32-bit integer elements.
        !! @param[in]	x	The first addend array of signed 16-bit integer elements.
        !! @param[in]	y	The second addend array of signed 16-bit integer elements.
        !! @param[out]	sum	The summand array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V16sV16s_V32s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V16sV16s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V16sV16s_V32s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two unsigned 16-bit integer arrays. Produces an array of unsigned 32-bit integer elements.
        !! @param[in]	x	The first addend array of unsigned 16-bit integer elements.
        !! @param[in]	y	The second addend array of unsigned 16-bit integer elements.
        !! @param[out]	sum	The summand array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V16uV16u_V32u & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V16uV16u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V16uV16u_V32u
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 32-bit integer arrays. Produces an array of signed 32-bit integer elements.
        !! @param[in]	x	The first addend array of signed 32-bit integer elements.
        !! @param[in]	y	The second addend array of signed 32-bit integer elements.
        !! @param[out]	sum	The summand array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V32sV32s_V32s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V32sV32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V32sV32s_V32s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 32-bit integer arrays. Produces an array of signed 64-bit integer elements.
        !! @param[in]	x	The first addend array of signed 32-bit integer elements.
        !! @param[in]	y	The second addend array of signed 32-bit integer elements.
        !! @param[out]	sum	The summand array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V32sV32s_V64s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V32sV32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V32sV32s_V64s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two unsigned 32-bit integer arrays. Produces an array of unsigned 64-bit integer elements.
        !! @param[in]	x	The first addend array of unsigned 32-bit integer elements.
        !! @param[in]	y	The second addend array of unsigned 32-bit integer elements.
        !! @param[out]	sum	The summand array of unsigned 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V32uV32u_V64u & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V32uV32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V32uV32u_V64u
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 64-bit integer arrays. Produces an array of signed 64-bit integer elements.
        !! @param[in]	x	The first addend array of signed 64-bit integer elements.
        !! @param[in]	y	The second addend array of signed 64-bit integer elements.
        !! @param[out]	sum	The summand array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V64sV64s_V64s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V64sV64s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V64sV64s_V64s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two single precision (32-bit) floating-point arrays. Produces an array of single precision (32-bit) floating-point elements.
        !! @param[in]	x	The first addend array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The second addend array of single precision (32-bit) floating-point elements.
        !! @param[out]	sum	The summand array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V32fV32f_V32f & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V32fV32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V32fV32f_V32f
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two double precision (64-bit) floating-point arrays. Produces an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The first addend array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The second addend array of double precision (64-bit) floating-point elements.
        !! @param[out]	sum	The summand array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V64fV64f_V64f & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V64fV64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V64fV64f_V64f
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 8-bit integer array elements. Produces an array of signed 8-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The addend array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant to be added.
        !! @param[out]	sum	The summand array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_V8sS8s_V8s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V8sS8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), VALUE                          :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V8sS8s_V8s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 8-bit integer array elements. Produces an array of signed 16-bit integer elements.
        !! @param[in]	x	The addend array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant to be added.
        !! @param[out]	sum	The summand array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>SSE2, AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V8sS8s_V16s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V8sS8s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), VALUE                           :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V8sS8s_V16s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to unsigned 8-bit integer array elements. Produces an array of unsigned 16-bit integer elements.
        !! @param[in]	x	The addend array of unsigned 8-bit integer elements.
        !! @param[in]	y	The unsigned 8-bit integer constant to be added.
        !! @param[out]	sum	The summand array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>SSE2, AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V8uS8u_V16u & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V8uS8u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), VALUE                           :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V8uS8u_V16u
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 16-bit integer array elements. Produces an array of signed 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The addend array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant to be added.
        !! @param[out]	sum	The summand array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_V16sS16s_V16s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V16sS16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V16sS16s_V16s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 16-bit integer array elements. Produces an array of signed 32-bit integer elements.
        !! @param[in]	x	The addend array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant to be added.
        !! @param[out]	sum	The summand array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>SSE2, AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V16sS16s_V32s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V16sS16s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V16sS16s_V32s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to unsigned 16-bit integer array elements. Produces an array of unsigned 32-bit integer elements.
        !! @param[in]	x	The addend array of unsigned 16-bit integer elements.
        !! @param[in]	y	The unsigned 16-bit integer constant to be added.
        !! @param[out]	sum	The summand array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>SSE2, AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V16uS16u_V32u & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V16uS16u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V16uS16u_V32u
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 32-bit integer array elements. Produces an array of signed 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The addend array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant to be added.
        !! @param[out]	sum	The summand array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_V32sS32s_V32s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V32sS32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V32sS32s_V32s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to unsigned 32-bit integer array elements. Produces an array of unsigned 64-bit integer elements.
        !! @param[in]	x	The addend array of unsigned 32-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant to be added.
        !! @param[out]	sum	The summand array of unsigned 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>SSE2, AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V32uS32u_V64u & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V32uS32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V32uS32u_V64u
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 32-bit integer array elements. Produces an array of signed 64-bit integer elements.
        !! @param[in]	x	The addend array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant to be added.
        !! @param[out]	sum	The summand array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>SSE2, AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Add_V32sS32s_V64s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V32sS32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V32sS32s_V64s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 64-bit integer array elements. Produces an array of signed 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The addend array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 64-bit integer constant to be added.
        !! @param[out]	sum	The summand array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_V64sS64s_V64s & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V64sS64s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT64_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V64sS64s_V64s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to single precision (32-bit) floating-point array elements. Produces an array of single precision (32-bit) floating-point elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The addend array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant to be added.
        !! @param[out]	sum	The summand array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_V32fS32f_V32f & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V32fS32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), VALUE                          :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V32fS32f_V32f
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to double precision (64-bit) floating-point array elements. Produces an array of double precision (64-bit) floating-point elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The addend array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant to be added.
        !! @param[out]	sum	The summand array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a sum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a sum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_V64fS64f_V64f & 
            (x, y, sum, length) &
            BIND(C, NAME='yepCore_Add_V64fS64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), VALUE                          :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: sum
        END FUNCTION yepCore_Add_V64fS64f_V64f
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 8-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first addend array of signed 8-bit integer elements.
        !! @param[in]	y	The second addend array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV8sV8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV8sV8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Add_IV8sV8s_IV8s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 16-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first addend array of signed 16-bit integer elements.
        !! @param[in]	y	The second addend array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV16sV16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV16sV16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Add_IV16sV16s_IV16s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 32-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first addend array of signed 32-bit integer elements.
        !! @param[in]	y	The second addend array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV32sV32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV32sV32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Add_IV32sV32s_IV32s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two signed 64-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first addend array of signed 64-bit integer elements.
        !! @param[in]	y	The second addend array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV64sV64s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV64sV64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Add_IV64sV64s_IV64s
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two single precision (32-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first addend array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The second addend array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV32fV32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV32fV32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Add_IV32fV32f_IV32f
        !> @ingroup	yepCore_Add
        !! @brief	Adds corresponding elements in two double precision (64-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first addend array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The second addend array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV64fV64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV64fV64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Add_IV64fV64f_IV64f
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 8-bit integer array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The addend array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant to be added.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV8sS8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV8sS8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), VALUE                            :: y
        END FUNCTION yepCore_Add_IV8sS8s_IV8s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 16-bit integer array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The addend array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant to be added.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV16sS16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV16sS16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), VALUE                            :: y
        END FUNCTION yepCore_Add_IV16sS16s_IV16s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 32-bit integer array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The addend array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant to be added.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV32sS32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV32sS32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Add_IV32sS32s_IV32s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to signed 64-bit integer array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The addend array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 64-bit integer constant to be added.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV64sS64s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV64sS64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT64_T), VALUE                            :: y
        END FUNCTION yepCore_Add_IV64sS64s_IV64s
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to single precision (32-bit) floating-point array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The addend array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant to be added.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV32fS32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV32fS32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), VALUE                            :: y
        END FUNCTION yepCore_Add_IV32fS32f_IV32f
        !> @ingroup	yepCore_Add
        !! @brief	Adds a constant to double precision (64-bit) floating-point array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The addend array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant to be added.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Add_IV64fS64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Add_IV64fS64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), VALUE                            :: y
        END FUNCTION yepCore_Add_IV64fS64f_IV64f
        !> @ingroup yepCore
        !! @defgroup yepCore_Subtract	Subtraction

        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 8-bit integer arrays. Produces an array of signed 8-bit integer elements.
        !! @param[in]	x	The minuend array of signed 8-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 8-bit integer elements.
        !! @param[out]	diff	The difference array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V8sV8s_V8s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V8sV8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V8sV8s_V8s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 8-bit integer arrays. Produces an array of signed 16-bit integer elements.
        !! @param[in]	x	The minuend array of signed 8-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 8-bit integer elements.
        !! @param[out]	diff	The difference array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V8sV8s_V16s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V8sV8s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V8sV8s_V16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two unsigned 8-bit integer arrays. Produces an array of unsigned 16-bit integer elements.
        !! @param[in]	x	The minuend array of unsigned 8-bit integer elements.
        !! @param[in]	y	The subtrahend array of unsigned 8-bit integer elements.
        !! @param[out]	diff	The difference array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V8uV8u_V16u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V8uV8u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V8uV8u_V16u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 16-bit integer arrays. Produces an array of signed 16-bit integer elements.
        !! @param[in]	x	The minuend array of signed 16-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 16-bit integer elements.
        !! @param[out]	diff	The difference array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V16sV16s_V16s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V16sV16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V16sV16s_V16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 16-bit integer arrays. Produces an array of signed 32-bit integer elements.
        !! @param[in]	x	The minuend array of signed 16-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 16-bit integer elements.
        !! @param[out]	diff	The difference array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V16sV16s_V32s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V16sV16s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V16sV16s_V32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two unsigned 16-bit integer arrays. Produces an array of unsigned 32-bit integer elements.
        !! @param[in]	x	The minuend array of unsigned 16-bit integer elements.
        !! @param[in]	y	The subtrahend array of unsigned 16-bit integer elements.
        !! @param[out]	diff	The difference array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V16uV16u_V32u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V16uV16u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V16uV16u_V32u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 32-bit integer arrays. Produces an array of signed 32-bit integer elements.
        !! @param[in]	x	The minuend array of signed 32-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 32-bit integer elements.
        !! @param[out]	diff	The difference array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32sV32s_V32s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V32sV32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V32sV32s_V32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 32-bit integer arrays. Produces an array of signed 64-bit integer elements.
        !! @param[in]	x	The minuend array of signed 32-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 32-bit integer elements.
        !! @param[out]	diff	The difference array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32sV32s_V64s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V32sV32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V32sV32s_V64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two unsigned 32-bit integer arrays. Produces an array of unsigned 64-bit integer elements.
        !! @param[in]	x	The minuend array of unsigned 32-bit integer elements.
        !! @param[in]	y	The subtrahend array of unsigned 32-bit integer elements.
        !! @param[out]	diff	The difference array of unsigned 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32uV32u_V64u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V32uV32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V32uV32u_V64u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 64-bit integer arrays. Produces an array of signed 64-bit integer elements.
        !! @param[in]	x	The minuend array of signed 64-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 64-bit integer elements.
        !! @param[out]	diff	The difference array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V64sV64s_V64s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V64sV64s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V64sV64s_V64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two single precision (32-bit) floating-point arrays. Produces an array of single precision (32-bit) floating-point elements.
        !! @param[in]	x	The minuend array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The subtrahend array of single precision (32-bit) floating-point elements.
        !! @param[out]	diff	The difference array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32fV32f_V32f & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V32fV32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V32fV32f_V32f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two double precision (64-bit) floating-point arrays. Produces an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The minuend array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The subtrahend array of double precision (64-bit) floating-point elements.
        !! @param[out]	diff	The difference array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a diff argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V64fV64f_V64f & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V64fV64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V64fV64f_V64f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 8-bit integer array elements. Produces an array of signed 8-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V8sS8s_V8s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V8sS8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), VALUE                          :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V8sS8s_V8s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 8-bit integer array elements. Produces an array of signed 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V8sS8s_V16s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V8sS8s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), VALUE                           :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V8sS8s_V16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from unsigned 8-bit integer array elements. Produces an array of unsigned 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of unsigned 8-bit integer elements.
        !! @param[in]	y	The unsigned 8-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V8uS8u_V16u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V8uS8u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), VALUE                           :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V8uS8u_V16u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 16-bit integer array elements. Produces an array of signed 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V16sS16s_V16s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V16sS16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V16sS16s_V16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 16-bit integer array elements. Produces an array of signed 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V16sS16s_V32s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V16sS16s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V16sS16s_V32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from unsigned 16-bit integer array elements. Produces an array of unsigned 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of unsigned 16-bit integer elements.
        !! @param[in]	y	The unsigned 16-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V16uS16u_V32u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V16uS16u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V16uS16u_V32u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 32-bit integer array elements. Produces an array of signed 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32sS32s_V32s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V32sS32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V32sS32s_V32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 32-bit integer array elements. Produces an array of signed 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32sS32s_V64s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V32sS32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V32sS32s_V64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from unsigned 32-bit integer array elements. Produces an array of unsigned 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of unsigned 32-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of unsigned 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32uS32u_V64u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V32uS32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V32uS32u_V64u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 64-bit integer array elements. Produces an array of signed 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 64-bit integer constant to be subtracted.
        !! @param[out]	diff	The difference array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V64sS64s_V64s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V64sS64s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT64_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V64sS64s_V64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from single precision (32-bit) floating-point array elements. Produces an array of single precision (32-bit) floating-point elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant to be subtracted.
        !! @param[out]	diff	The difference array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32fS32f_V32f & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V32fS32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), VALUE                          :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V32fS32f_V32f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from double precision (64-bit) floating-point array elements. Produces an array of double precision (64-bit) floating-point elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant to be subtracted.
        !! @param[out]	diff	The difference array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V64fS64f_V64f & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_V64fS64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), VALUE                          :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_V64fS64f_V64f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 8-bit integer array elements from a constant. Produces an array of signed 8-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 8-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of signed 8-bit integer elements.
        !! @param[out]	diff	The difference array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S8sV8s_V8s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S8sV8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), VALUE                          :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S8sV8s_V8s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 8-bit integer array elements from a constant. Produces an array of signed 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 8-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of signed 8-bit integer elements.
        !! @param[out]	diff	The difference array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S8sV8s_V16s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S8sV8s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), VALUE                           :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S8sV8s_V16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts unsigned 8-bit integer array elements from a constant. Produces an array of unsigned 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The unsigned 8-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of unsigned 8-bit integer elements.
        !! @param[out]	diff	The difference array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S8uV8u_V16u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S8uV8u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), VALUE                           :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S8uV8u_V16u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 16-bit integer array elements from a constant. Produces an array of signed 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 16-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of signed 16-bit integer elements.
        !! @param[out]	diff	The difference array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S16sV16s_V16s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S16sV16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), VALUE                          :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S16sV16s_V16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 16-bit integer array elements from a constant. Produces an array of signed 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 16-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of signed 16-bit integer elements.
        !! @param[out]	diff	The difference array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S16sV16s_V32s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S16sV16s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), VALUE                          :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S16sV16s_V32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts unsigned 16-bit integer array elements from a constant. Produces an array of unsigned 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The unsigned 16-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of unsigned 16-bit integer elements.
        !! @param[out]	diff	The difference array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S16uV16u_V32u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S16uV16u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), VALUE                          :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S16uV16u_V32u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 32-bit integer array elements from a constant. Produces an array of signed 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 32-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of signed 32-bit integer elements.
        !! @param[out]	diff	The difference array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S32sV32s_V32s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S32sV32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), VALUE                          :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S32sV32s_V32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 32-bit integer array elements from a constant. Produces an array of signed 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 32-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of signed 32-bit integer elements.
        !! @param[out]	diff	The difference array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S32sV32s_V64s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S32sV32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), VALUE                          :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S32sV32s_V64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts unsigned 32-bit integer array elements from a constant. Produces an array of unsigned 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The unsigned 32-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of unsigned 32-bit integer elements.
        !! @param[out]	diff	The difference array of unsigned 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S32uV32u_V64u & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S32uV32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), VALUE                          :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S32uV32u_V64u
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 64-bit integer array elements from a constant. Produces an array of signed 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 64-bit integer constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of signed 64-bit integer elements.
        !! @param[out]	diff	The difference array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S64sV64s_V64s & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S64sV64s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), VALUE                          :: x
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S64sV64s_V64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts single precision (32-bit) floating-point array elements from a constant. Produces an array of single precision (32-bit) floating-point elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The single precision (32-bit) floating-point constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of single precision (32-bit) floating-point elements.
        !! @param[out]	diff	The difference array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S32fV32f_V32f & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S32fV32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), VALUE                          :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S32fV32f_V32f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts double precision (64-bit) floating-point array elements from a constant. Produces an array of double precision (64-bit) floating-point elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The double precision (64-bit) floating-point constant to be subtracted from.
        !! @param[in]	y	The subtrahend array of double precision (64-bit) floating-point elements.
        !! @param[out]	diff	The difference array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a y and @a diff.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y or @a diff argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S64fV64f_V64f & 
            (x, y, diff, length) &
            BIND(C, NAME='yepCore_Subtract_S64fV64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), VALUE                          :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: diff
        END FUNCTION yepCore_Subtract_S64fV64f_V64f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 8-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of signed 8-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV8sV8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV8sV8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Subtract_IV8sV8s_IV8s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 16-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of signed 16-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV16sV16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV16sV16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Subtract_IV16sV16s_IV16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 32-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of signed 32-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV32sV32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV32sV32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Subtract_IV32sV32s_IV32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 64-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of signed 64-bit integer elements.
        !! @param[in]	y	The subtrahend array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV64sV64s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV64sV64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Subtract_IV64sV64s_IV64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two single precision (32-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The subtrahend array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV32fV32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV32fV32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Subtract_IV32fV32f_IV32f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two double precision (64-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The subtrahend array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV64fV64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV64fV64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Subtract_IV64fV64f_IV64f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 8-bit integer arrays and writes the result to the second array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 8-bit integer elements.
        !! @param[in,out]	y	The subtrahend array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V8sIV8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_V8sIV8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)    :: x
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_V8sIV8s_IV8s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 16-bit integer arrays and writes the result to the second array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 16-bit integer elements.
        !! @param[in,out]	y	The subtrahend array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V16sIV16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_V16sIV16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)    :: x
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_V16sIV16s_IV16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 32-bit integer arrays and writes the result to the second array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 32-bit integer elements.
        !! @param[in,out]	y	The subtrahend array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32sIV32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_V32sIV32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: x
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_V32sIV32s_IV32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two signed 64-bit integer arrays and writes the result to the second array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of signed 64-bit integer elements.
        !! @param[in,out]	y	The subtrahend array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V64sIV64s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_V64sIV64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)    :: x
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_V64sIV64s_IV64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two single precision (32-bit) floating-point arrays and writes the result to the second array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of single precision (32-bit) floating-point elements.
        !! @param[in,out]	y	The subtrahend array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V32fIV32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_V32fIV32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)    :: x
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_V32fIV32f_IV32f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts corresponding elements in two double precision (64-bit) floating-point arrays and writes the result to the second array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The minuend array of double precision (64-bit) floating-point elements.
        !! @param[in,out]	y	The subtrahend array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_V64fIV64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_V64fIV64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)    :: x
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_V64fIV64f_IV64f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 8-bit integer array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant to be subtracted.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV8sS8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV8sS8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), VALUE                            :: y
        END FUNCTION yepCore_Subtract_IV8sS8s_IV8s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 16-bit integer array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant to be subtracted.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV16sS16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV16sS16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), VALUE                            :: y
        END FUNCTION yepCore_Subtract_IV16sS16s_IV16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 32-bit integer array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant to be subtracted.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV32sS32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV32sS32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Subtract_IV32sS32s_IV32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from signed 64-bit integer array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 64-bit integer constant to be subtracted.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV64sS64s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV64sS64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT64_T), VALUE                            :: y
        END FUNCTION yepCore_Subtract_IV64sS64s_IV64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from single precision (32-bit) floating-point array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant to be subtracted.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV32fS32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV32fS32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), VALUE                            :: y
        END FUNCTION yepCore_Subtract_IV32fS32f_IV32f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts a constant from double precision (64-bit) floating-point array elements and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The minuend array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant to be subtracted.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_IV64fS64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_IV64fS64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), VALUE                            :: y
        END FUNCTION yepCore_Subtract_IV64fS64f_IV64f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 8-bit integer array elements from a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 8-bit integer constant to be subtracted from.
        !! @param[in,out]	y	The subtrahend array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the array specified by @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S8sIV8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_S8sIV8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), VALUE                            :: x
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_S8sIV8s_IV8s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 16-bit integer array elements from a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 16-bit integer constant to be subtracted from.
        !! @param[in,out]	y	The subtrahend array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the array specified by @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S16sIV16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_S16sIV16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), VALUE                            :: x
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_S16sIV16s_IV16s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 32-bit integer array elements from a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 32-bit integer constant to be subtracted from.
        !! @param[in,out]	y	The subtrahend array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the array specified by @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S32sIV32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_S32sIV32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), VALUE                            :: x
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_S32sIV32s_IV32s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts signed 64-bit integer array elements from a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The signed 64-bit integer constant to be subtracted from.
        !! @param[in,out]	y	The subtrahend array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the array specified by @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S64sIV64s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_S64sIV64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), VALUE                            :: x
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_S64sIV64s_IV64s
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts single precision (32-bit) floating-point array elements from a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The single precision (32-bit) floating-point constant to be subtracted from.
        !! @param[in,out]	y	The subtrahend array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the array specified by @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S32fIV32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_S32fIV32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), VALUE                            :: x
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_S32fIV32f_IV32f
        !> @ingroup	yepCore_Subtract
        !! @brief	Subtracts double precision (64-bit) floating-point array elements from a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The double precision (64-bit) floating-point constant to be subtracted from.
        !! @param[in,out]	y	The subtrahend array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the array specified by @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Subtract_S64fIV64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Subtract_S64fIV64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), VALUE                            :: x
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Subtract_S64fIV64f_IV64f
        !> @ingroup yepCore
        !! @defgroup yepCore_Negate	Negation

        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in signed 8-bit integer array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The array of signed 8-bit integer elements to be negated.
        !! @param[out]	y	The signed 8-bit integer array to store negated elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_V8s_V8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Negate_V8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Negate_V8s_V8s
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in signed 16-bit integer array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The array of signed 16-bit integer elements to be negated.
        !! @param[out]	y	The signed 16-bit integer array to store negated elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_V16s_V16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Negate_V16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Negate_V16s_V16s
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in signed 32-bit integer array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The array of signed 32-bit integer elements to be negated.
        !! @param[out]	y	The signed 32-bit integer array to store negated elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_V32s_V32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Negate_V32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Negate_V32s_V32s
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in signed 64-bit integer array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The array of signed 64-bit integer elements to be negated.
        !! @param[out]	y	The signed 64-bit integer array to store negated elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_V64s_V64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Negate_V64s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Negate_V64s_V64s
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in single precision (32-bit) floating-point array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The array of single precision (32-bit) floating-point elements to be negated.
        !! @param[out]	y	The single precision (32-bit) floating-point array to store negated elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_V32f_V32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Negate_V32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Negate_V32f_V32f
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in double precision (64-bit) floating-point array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The array of double precision (64-bit) floating-point elements to be negated.
        !! @param[out]	y	The double precision (64-bit) floating-point array to store negated elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_V64f_V64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Negate_V64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepCore_Negate_V64f_V64f
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in signed 8-bit integer array and writes the results to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	v	The array of signed 8-bit integer elements to be negated.
        !! @param[in]	length	Length of the array specified by @a v.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_IV8s_IV8s & 
            (v, length) &
            BIND(C, NAME='yepCore_Negate_IV8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: v
        END FUNCTION yepCore_Negate_IV8s_IV8s
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in signed 16-bit integer array and writes the results to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	v	The array of signed 16-bit integer elements to be negated.
        !! @param[in]	length	Length of the array specified by @a v.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_IV16s_IV16s & 
            (v, length) &
            BIND(C, NAME='yepCore_Negate_IV16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: v
        END FUNCTION yepCore_Negate_IV16s_IV16s
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in signed 32-bit integer array and writes the results to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	v	The array of signed 32-bit integer elements to be negated.
        !! @param[in]	length	Length of the array specified by @a v.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_IV32s_IV32s & 
            (v, length) &
            BIND(C, NAME='yepCore_Negate_IV32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: v
        END FUNCTION yepCore_Negate_IV32s_IV32s
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in signed 64-bit integer array and writes the results to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	v	The array of signed 64-bit integer elements to be negated.
        !! @param[in]	length	Length of the array specified by @a v.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_IV64s_IV64s & 
            (v, length) &
            BIND(C, NAME='yepCore_Negate_IV64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: v
        END FUNCTION yepCore_Negate_IV64s_IV64s
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in single precision (32-bit) floating-point array and writes the results to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	v	The array of single precision (32-bit) floating-point elements to be negated.
        !! @param[in]	length	Length of the array specified by @a v.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_IV32f_IV32f & 
            (v, length) &
            BIND(C, NAME='yepCore_Negate_IV32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: v
        END FUNCTION yepCore_Negate_IV32f_IV32f
        !> @ingroup	yepCore_Negate
        !! @brief	Negates elements in double precision (64-bit) floating-point array and writes the results to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	v	The array of double precision (64-bit) floating-point elements to be negated.
        !! @param[in]	length	Length of the array specified by @a v.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Negate_IV64f_IV64f & 
            (v, length) &
            BIND(C, NAME='yepCore_Negate_IV64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: v
        END FUNCTION yepCore_Negate_IV64f_IV64f
        !> @ingroup yepCore
        !! @defgroup yepCore_Multiply	Multiplication

        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two signed 8-bit integer arrays, producing an array of signed 8-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first factor array of signed 8-bit integer elements.
        !! @param[in]	y	The second factor array of signed 8-bit integer elements.
        !! @param[out]	product	The product array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V8sV8s_V8s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V8sV8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V8sV8s_V8s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two signed 8-bit integer arrays, producing an array of signed 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first factor array of signed 8-bit integer elements.
        !! @param[in]	y	The second factor array of signed 8-bit integer elements.
        !! @param[out]	product	The product array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V8sV8s_V16s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V8sV8s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V8sV8s_V16s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two unsigned 8-bit integer arrays, producing an array of unsigned 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first factor array of unsigned 8-bit integer elements.
        !! @param[in]	y	The second factor array of unsigned 8-bit integer elements.
        !! @param[out]	product	The product array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V8uV8u_V16u & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V8uV8u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V8uV8u_V16u
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two signed 16-bit integer arrays, producing an array of signed 16-bit integer elements.
        !! @param[in]	x	The first factor array of signed 16-bit integer elements.
        !! @param[in]	y	The second factor array of signed 16-bit integer elements.
        !! @param[out]	product	The product array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V16sV16s_V16s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V16sV16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V16sV16s_V16s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two signed 16-bit integer arrays, producing an array of signed 32-bit integer elements.
        !! @param[in]	x	The first factor array of signed 16-bit integer elements.
        !! @param[in]	y	The second factor array of signed 16-bit integer elements.
        !! @param[out]	product	The product array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V16sV16s_V32s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V16sV16s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V16sV16s_V32s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two unsigned 16-bit integer arrays, producing an array of unsigned 32-bit integer elements.
        !! @param[in]	x	The first factor array of unsigned 16-bit integer elements.
        !! @param[in]	y	The second factor array of unsigned 16-bit integer elements.
        !! @param[out]	product	The product array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V16uV16u_V32u & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V16uV16u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V16uV16u_V32u
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two signed 32-bit integer arrays, producing an array of signed 32-bit integer elements.
        !! @param[in]	x	The first factor array of signed 32-bit integer elements.
        !! @param[in]	y	The second factor array of signed 32-bit integer elements.
        !! @param[out]	product	The product array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V32sV32s_V32s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V32sV32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V32sV32s_V32s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two signed 32-bit integer arrays, producing an array of signed 64-bit integer elements.
        !! @param[in]	x	The first factor array of signed 32-bit integer elements.
        !! @param[in]	y	The second factor array of signed 32-bit integer elements.
        !! @param[out]	product	The product array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V32sV32s_V64s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V32sV32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V32sV32s_V64s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two unsigned 32-bit integer arrays, producing an array of unsigned 64-bit integer elements.
        !! @param[in]	x	The first factor array of unsigned 32-bit integer elements.
        !! @param[in]	y	The second factor array of unsigned 32-bit integer elements.
        !! @param[out]	product	The product array of unsigned 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V32uV32u_V64u & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V32uV32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V32uV32u_V64u
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two signed 64-bit integer arrays, producing an array of signed 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first factor array of signed 64-bit integer elements.
        !! @param[in]	y	The second factor array of signed 64-bit integer elements.
        !! @param[out]	product	The product array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V64sV64s_V64s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V64sV64s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V64sV64s_V64s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two single precision (32-bit) floating-point arrays, producing an array of single precision (32-bit) floating-point elements.
        !! @param[in]	x	The first factor array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The second factor array of single precision (32-bit) floating-point elements.
        !! @param[out]	product	The product array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V32fV32f_V32f & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V32fV32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V32fV32f_V32f
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiples corresponding elements in two double precision (64-bit) floating-point arrays, producing an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The first factor array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The second factor array of double precision (64-bit) floating-point elements.
        !! @param[out]	product	The product array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a product argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V64fV64f_V64f & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V64fV64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V64fV64f_V64f
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 8-bit integer array elements by a constant. Produces an array of signed 8-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V8sS8s_V8s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V8sS8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), VALUE                          :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V8sS8s_V8s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 8-bit integer array elements by a constant. Produces an array of signed 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V8sS8s_V16s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V8sS8s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), VALUE                           :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V8sS8s_V16s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies unsigned 8-bit integer array elements by a constant. Produces an array of unsigned 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of unsigned 8-bit integer elements.
        !! @param[in]	y	The unsigned 8-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V8uS8u_V16u & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V8uS8u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)   :: x
            INTEGER(C_INT8_T), VALUE                           :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V8uS8u_V16u
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 16-bit integer array elements by a constant. Produces an array of signed 16-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V16sS16s_V16s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V16sS16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V16sS16s_V16s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 16-bit integer array elements by a constant. Produces an array of signed 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V16sS16s_V32s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V16sS16s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V16sS16s_V32s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies unsigned 16-bit integer array elements by a constant. Produces an array of unsigned 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of unsigned 16-bit integer elements.
        !! @param[in]	y	The unsigned 16-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V16uS16u_V32u & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V16uS16u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V16uS16u_V32u
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 32-bit integer array elements by a constant. Produces an array of signed 32-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V32sS32s_V32s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V32sS32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V32sS32s_V32s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 32-bit integer array elements by a constant. Produces an array of signed 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V32sS32s_V64s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V32sS32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V32sS32s_V64s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies unsigned 32-bit integer array elements by a constant. Produces an array of unsigned 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of unsigned 32-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of unsigned 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V32uS32u_V64u & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V32uS32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V32uS32u_V64u
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 64-bit integer array elements by a constant. Produces an array of signed 64-bit integer elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 64-bit integer constant to be multiplied by.
        !! @param[out]	product	The product array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V64sS64s_V64s & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V64sS64s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT64_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V64sS64s_V64s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies single precision (32-bit) floating-point array elements by a constant. Produces an array of single precision (32-bit) floating-point elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant to be multiplied by.
        !! @param[out]	product	The product array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V32fS32f_V32f & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V32fS32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), VALUE                          :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V32fS32f_V32f
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies double precision (64-bit) floating-point array elements by a constant. Produces an array of double precision (64-bit) floating-point elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The factor array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant to be multiplied by.
        !! @param[out]	product	The product array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a product.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a product argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_V64fS64f_V64f & 
            (x, y, product, length) &
            BIND(C, NAME='yepCore_Multiply_V64fS64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), VALUE                          :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: product
        END FUNCTION yepCore_Multiply_V64fS64f_V64f
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies corresponding elements in two signed 8-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first factor array of signed 8-bit integer elements.
        !! @param[in]	y	The second factor array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV8sV8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV8sV8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Multiply_IV8sV8s_IV8s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies corresponding elements in two signed 16-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first factor array of signed 16-bit integer elements.
        !! @param[in]	y	The second factor array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV16sV16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV16sV16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Multiply_IV16sV16s_IV16s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies corresponding elements in two signed 32-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first factor array of signed 32-bit integer elements.
        !! @param[in]	y	The second factor array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV32sV32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV32sV32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Multiply_IV32sV32s_IV32s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies corresponding elements in two signed 64-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first factor array of signed 64-bit integer elements.
        !! @param[in]	y	The second factor array of signed 64-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV64sV64s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV64sV64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Multiply_IV64sV64s_IV64s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies corresponding elements in two single precision (32-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first factor array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The second factor array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV32fV32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV32fV32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Multiply_IV32fV32f_IV32f
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies corresponding elements in two double precision (64-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first factor array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The second factor array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV64fV64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV64fV64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Multiply_IV64fV64f_IV64f
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 8-bit integer array elements by a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The factor array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant factor.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV8sS8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV8sS8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), VALUE                            :: y
        END FUNCTION yepCore_Multiply_IV8sS8s_IV8s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 16-bit integer array elements by a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The factor array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant factor.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV16sS16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV16sS16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), VALUE                            :: y
        END FUNCTION yepCore_Multiply_IV16sS16s_IV16s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 32-bit integer array elements by a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The factor array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant factor.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV32sS32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV32sS32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Multiply_IV32sS32s_IV32s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies signed 64-bit integer array elements by a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The factor array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 64-bit integer constant factor.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV64sS64s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV64sS64s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT64_T), VALUE                            :: y
        END FUNCTION yepCore_Multiply_IV64sS64s_IV64s
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies single precision (32-bit) floating-point array elements by a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The factor array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant factor.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV32fS32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV32fS32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), VALUE                            :: y
        END FUNCTION yepCore_Multiply_IV32fS32f_IV32f
        !> @ingroup	yepCore_Multiply
        !! @brief	Multiplies double precision (64-bit) floating-point array elements by a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The factor array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant factor.
        !! @param[in]	length	Length of the array specified by @a x.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Multiply_IV64fS64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Multiply_IV64fS64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), VALUE                            :: y
        END FUNCTION yepCore_Multiply_IV64fS64f_IV64f
        !> @ingroup yepCore
        !! @defgroup yepCore_Min	Minimum

        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of signed 8-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V8s_S8s & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V8s_S8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT8_T), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V8s_S8s
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of unsigned 8-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V8u_S8u & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V8u_S8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT8_T), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V8u_S8u
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of signed 16-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V16s_S16s & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V16s_S16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT16_T), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V16s_S16s
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of unsigned 16-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V16u_S16u & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V16u_S16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT16_T), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V16u_S16u
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of signed 32-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V32s_S32s & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32s_S32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT32_T), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V32s_S32s
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of unsigned 32-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V32u_S32u & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32u_S32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT32_T), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V32u_S32u
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of signed 64-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V64s_S64s & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64s_S64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT64_T), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V64s_S64s
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of unsigned 64-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V64u_S64u & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64u_S64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT64_T), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V64u_S64u
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of single precision (32-bit) floating-point array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V32f_S32f & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32f_S32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                     :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length) :: v
            REAL(C_FLOAT), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V32f_S32f
        !> @ingroup	yepCore_Min
        !! @brief	Computes the minimum of double precision (64-bit) floating-point array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose minimum will be computed.
        !! @param[out]	minimum	The variable where the minimum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a minimum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Min_V64f_S64f & 
            (v, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64f_S64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length) :: v
            REAL(C_DOUBLE), INTENT(OUT)                   :: minimum
        END FUNCTION yepCore_Min_V64f_S64f
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two signed 8-bit integer arrays.
        !! @param[in]	x	The first array of signed 8-bit integer elements.
        !! @param[in]	y	The second array of signed 8-bit integer elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Min_V8sV8s_V8s & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V8sV8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V8sV8s_V8s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two unsigned 8-bit integer arrays.
        !! @param[in]	x	The first array of unsigned 8-bit integer elements.
        !! @param[in]	y	The second array of unsigned 8-bit integer elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Min_V8uV8u_V8u & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V8uV8u_V8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V8uV8u_V8u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two signed 16-bit integer arrays.
        !! @param[in]	x	The first array of signed 16-bit integer elements.
        !! @param[in]	y	The second array of signed 16-bit integer elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Min_V16sV16s_V16s & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V16sV16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V16sV16s_V16s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two unsigned 16-bit integer arrays.
        !! @param[in]	x	The first array of unsigned 16-bit integer elements.
        !! @param[in]	y	The second array of unsigned 16-bit integer elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Min_V16uV16u_V16u & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V16uV16u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V16uV16u_V16u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two signed 32-bit integer arrays.
        !! @param[in]	x	The first array of signed 32-bit integer elements.
        !! @param[in]	y	The second array of signed 32-bit integer elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Min_V32sV32s_V32s & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32sV32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V32sV32s_V32s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two unsigned 32-bit integer arrays.
        !! @param[in]	x	The first array of unsigned 32-bit integer elements.
        !! @param[in]	y	The second array of unsigned 32-bit integer elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Min_V32uV32u_V32u & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32uV32u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V32uV32u_V32u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two signed 64-bit integer arrays.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 64-bit integer elements.
        !! @param[in]	y	The second array of signed 32-bit integer elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V64sV32s_V64s & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64sV32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V64sV32s_V64s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two unsigned 64-bit integer arrays.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 64-bit integer elements.
        !! @param[in]	y	The second array of unsigned 32-bit integer elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V64uV32u_V64u & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64uV32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V64uV32u_V64u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two single precision (32-bit) floating-point arrays.
        !! @param[in]	x	The first array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The second array of single precision (32-bit) floating-point elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Min_V32fV32f_V32f & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32fV32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V32fV32f_V32f
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two double precision (64-bit) floating-point arrays.
        !! @param[in]	x	The first array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The second array of double precision (64-bit) floating-point elements.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a minimum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Min_V64fV64f_V64f & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64fV64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V64fV64f_V64f
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of signed 8-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V8sS8s_V8s & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V8sS8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), VALUE                          :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V8sS8s_V8s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of unsigned 8-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 8-bit integer elements.
        !! @param[in]	y	The unsigned 8-bit integer constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V8uS8u_V8u & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V8uS8u_V8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), VALUE                          :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V8uS8u_V8u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of signed 16-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V16sS16s_V16s & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V16sS16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V16sS16s_V16s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of unsigned 16-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 16-bit integer elements.
        !! @param[in]	y	The unsigned 16-bit integer constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V16uS16u_V16u & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V16uS16u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V16uS16u_V16u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of signed 32-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V32sS32s_V32s & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32sS32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V32sS32s_V32s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of unsigned 32-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 32-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V32uS32u_V32u & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32uS32u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V32uS32u_V32u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of signed 64-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V64sS32s_V64s & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64sS32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V64sS32s_V64s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of unsigned 64-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 64-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V64uS32u_V64u & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64uS32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V64uS32u_V64u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of single precision (32-bit) floating-point array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V32fS32f_V32f & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V32fS32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), VALUE                          :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V32fS32f_V32f
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of double precision (64-bit) floating-point array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant.
        !! @param[out]	minimum	The array of pairwise minimum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a minimum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a minimum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_V64fS64f_V64f & 
            (x, y, minimum, length) &
            BIND(C, NAME='yepCore_Min_V64fS64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), VALUE                          :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: minimum
        END FUNCTION yepCore_Min_V64fS64f_V64f
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two signed 8-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of signed 8-bit integer elements.
        !! @param[in]	y	The second array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV8sV8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV8sV8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV8sV8s_IV8s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two unsigned 8-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of unsigned 8-bit integer elements.
        !! @param[in]	y	The second array of unsigned 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV8uV8u_IV8u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV8uV8u_IV8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV8uV8u_IV8u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two signed 16-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of signed 16-bit integer elements.
        !! @param[in]	y	The second array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV16sV16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV16sV16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV16sV16s_IV16s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two unsigned 16-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of unsigned 16-bit integer elements.
        !! @param[in]	y	The second array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV16uV16u_IV16u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV16uV16u_IV16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV16uV16u_IV16u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two signed 32-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of signed 32-bit integer elements.
        !! @param[in]	y	The second array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV32sV32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV32sV32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV32sV32s_IV32s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two unsigned 32-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of unsigned 32-bit integer elements.
        !! @param[in]	y	The second array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV32uV32u_IV32u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV32uV32u_IV32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV32uV32u_IV32u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two signed 64-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of signed 64-bit integer elements.
        !! @param[in]	y	The second array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV64sV32s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV64sV32s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV64sV32s_IV64s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two unsigned 64-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of unsigned 64-bit integer elements.
        !! @param[in]	y	The second array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV64uV32u_IV64u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV64uV32u_IV64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV64uV32u_IV64u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two single precision (32-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The second array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV32fV32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV32fV32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV32fV32f_IV32f
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of corresponding elements in two double precision (64-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The second array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV64fV64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV64fV64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Min_IV64fV64f_IV64f
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of signed 8-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV8sS8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV8sS8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), VALUE                            :: y
        END FUNCTION yepCore_Min_IV8sS8s_IV8s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of unsigned 8-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of unsigned 8-bit integer elements.
        !! @param[in]	y	The unsigned 8-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV8uS8u_IV8u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV8uS8u_IV8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), VALUE                            :: y
        END FUNCTION yepCore_Min_IV8uS8u_IV8u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of signed 16-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV16sS16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV16sS16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), VALUE                            :: y
        END FUNCTION yepCore_Min_IV16sS16s_IV16s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of unsigned 16-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of unsigned 16-bit integer elements.
        !! @param[in]	y	The unsigned 16-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV16uS16u_IV16u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV16uS16u_IV16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), VALUE                            :: y
        END FUNCTION yepCore_Min_IV16uS16u_IV16u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of signed 32-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV32sS32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV32sS32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Min_IV32sS32s_IV32s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of unsigned 32-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of unsigned 32-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV32uS32u_IV32u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV32uS32u_IV32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Min_IV32uS32u_IV32u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of signed 64-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV64sS32s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV64sS32s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Min_IV64sS32s_IV64s
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of unsigned 64-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of unsigned 64-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV64uS32u_IV64u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV64uS32u_IV64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Min_IV64uS32u_IV64u
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of single precision (32-bit) floating-point array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV32fS32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV32fS32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), VALUE                            :: y
        END FUNCTION yepCore_Min_IV32fS32f_IV32f
        !> @ingroup	yepCore_Min
        !! @brief	Computes pairwise minima of double precision (64-bit) floating-point array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Min_IV64fS64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Min_IV64fS64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), VALUE                            :: y
        END FUNCTION yepCore_Min_IV64fS64f_IV64f
        !> @ingroup yepCore
        !! @defgroup yepCore_Max	Maximum

        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of signed 8-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V8s_S8s & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V8s_S8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT8_T), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V8s_S8s
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of unsigned 8-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V8u_S8u & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V8u_S8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT8_T), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V8u_S8u
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of signed 16-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V16s_S16s & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V16s_S16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT16_T), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V16s_S16s
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of unsigned 16-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V16u_S16u & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V16u_S16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT16_T), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V16u_S16u
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of signed 32-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V32s_S32s & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32s_S32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT32_T), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V32s_S32s
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of unsigned 32-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V32u_S32u & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32u_S32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT32_T), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V32u_S32u
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of signed 64-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V64s_S64s & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64s_S64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT64_T), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V64s_S64s
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of unsigned 64-bit integer array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V64u_S64u & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64u_S64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length) :: v
            INTEGER(C_INT64_T), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V64u_S64u
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of single precision (32-bit) floating-point array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V32f_S32f & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32f_S32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                     :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length) :: v
            REAL(C_FLOAT), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V32f_S32f
        !> @ingroup	yepCore_Max
        !! @brief	Computes the maximum of double precision (64-bit) floating-point array elements.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	v	The array of elements whose maximum will be computed.
        !! @param[out]	maximum	The variable where the maximum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. Must be non-zero.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a maximum argument is not naturally aligned.
        !! @retval	3	@a length argument is zero.
        INTEGER(C_INT) FUNCTION yepCore_Max_V64f_S64f & 
            (v, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64f_S64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length) :: v
            REAL(C_DOUBLE), INTENT(OUT)                   :: maximum
        END FUNCTION yepCore_Max_V64f_S64f
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two signed 8-bit integer arrays.
        !! @param[in]	x	The first array of signed 8-bit integer elements.
        !! @param[in]	y	The second array of signed 8-bit integer elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Max_V8sV8s_V8s & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V8sV8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V8sV8s_V8s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two unsigned 8-bit integer arrays.
        !! @param[in]	x	The first array of unsigned 8-bit integer elements.
        !! @param[in]	y	The second array of unsigned 8-bit integer elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Max_V8uV8u_V8u & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V8uV8u_V8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V8uV8u_V8u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two signed 16-bit integer arrays.
        !! @param[in]	x	The first array of signed 16-bit integer elements.
        !! @param[in]	y	The second array of signed 16-bit integer elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Max_V16sV16s_V16s & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V16sV16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V16sV16s_V16s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two unsigned 16-bit integer arrays.
        !! @param[in]	x	The first array of unsigned 16-bit integer elements.
        !! @param[in]	y	The second array of unsigned 16-bit integer elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Max_V16uV16u_V16u & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V16uV16u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V16uV16u_V16u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two signed 32-bit integer arrays.
        !! @param[in]	x	The first array of signed 32-bit integer elements.
        !! @param[in]	y	The second array of signed 32-bit integer elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Max_V32sV32s_V32s & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32sV32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V32sV32s_V32s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two unsigned 32-bit integer arrays.
        !! @param[in]	x	The first array of unsigned 32-bit integer elements.
        !! @param[in]	y	The second array of unsigned 32-bit integer elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Max_V32uV32u_V32u & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32uV32u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V32uV32u_V32u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two signed 64-bit integer arrays.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 64-bit integer elements.
        !! @param[in]	y	The second array of signed 32-bit integer elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V64sV32s_V64s & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64sV32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V64sV32s_V64s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two unsigned 64-bit integer arrays.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 64-bit integer elements.
        !! @param[in]	y	The second array of unsigned 32-bit integer elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V64uV32u_V64u & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64uV32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V64uV32u_V64u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two single precision (32-bit) floating-point arrays.
        !! @param[in]	x	The first array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The second array of single precision (32-bit) floating-point elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Max_V32fV32f_V32f & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32fV32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V32fV32f_V32f
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two double precision (64-bit) floating-point arrays.
        !! @param[in]	x	The first array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The second array of double precision (64-bit) floating-point elements.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a maximum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Max_V64fV64f_V64f & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64fV64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V64fV64f_V64f
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of signed 8-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V8sS8s_V8s & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V8sS8s_V8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), VALUE                          :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V8sS8s_V8s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of unsigned 8-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 8-bit integer elements.
        !! @param[in]	y	The unsigned 8-bit integer constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V8uS8u_V8u & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V8uS8u_V8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                          :: length
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT8_T), VALUE                          :: y
            INTEGER(C_INT8_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V8uS8u_V8u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of signed 16-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V16sS16s_V16s & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V16sS16s_V16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V16sS16s_V16s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of unsigned 16-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 16-bit integer elements.
        !! @param[in]	y	The unsigned 16-bit integer constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V16uS16u_V16u & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V16uS16u_V16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT16_T), VALUE                          :: y
            INTEGER(C_INT16_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V16uS16u_V16u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of signed 32-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V32sS32s_V32s & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32sS32s_V32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V32sS32s_V32s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of unsigned 32-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 32-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V32uS32u_V32u & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32uS32u_V32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT32_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V32uS32u_V32u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of signed 64-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V64sS32s_V64s & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64sS32s_V64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V64sS32s_V64s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of unsigned 64-bit integer array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of unsigned 64-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V64uS32u_V64u & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64uS32u_V64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                           :: length
            INTEGER(C_INT64_T), INTENT(IN), DIMENSION(length)  :: x
            INTEGER(C_INT32_T), VALUE                          :: y
            INTEGER(C_INT64_T), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V64uS32u_V64u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of single precision (32-bit) floating-point array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V32fS32f_V32f & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V32fS32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_FLOAT), VALUE                          :: y
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V32fS32f_V32f
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of double precision (64-bit) floating-point array elements and a constant.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in]	x	The first array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant.
        !! @param[out]	maximum	The array of pairwise maximum elements.
        !! @param[in]	length	Length of the arrays specified by @a x, @a y, and @a maximum.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a maximum argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_V64fS64f_V64f & 
            (x, y, maximum, length) &
            BIND(C, NAME='yepCore_Max_V64fS64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), VALUE                          :: y
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: maximum
        END FUNCTION yepCore_Max_V64fS64f_V64f
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two signed 8-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of signed 8-bit integer elements.
        !! @param[in]	y	The second array of signed 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV8sV8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV8sV8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV8sV8s_IV8s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two unsigned 8-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of unsigned 8-bit integer elements.
        !! @param[in]	y	The second array of unsigned 8-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV8uV8u_IV8u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV8uV8u_IV8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV8uV8u_IV8u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two signed 16-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of signed 16-bit integer elements.
        !! @param[in]	y	The second array of signed 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV16sV16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV16sV16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV16sV16s_IV16s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two unsigned 16-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of unsigned 16-bit integer elements.
        !! @param[in]	y	The second array of unsigned 16-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV16uV16u_IV16u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV16uV16u_IV16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV16uV16u_IV16u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two signed 32-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of signed 32-bit integer elements.
        !! @param[in]	y	The second array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV32sV32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV32sV32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV32sV32s_IV32s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two unsigned 32-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of unsigned 32-bit integer elements.
        !! @param[in]	y	The second array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV32uV32u_IV32u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV32uV32u_IV32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV32uV32u_IV32u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two signed 64-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of signed 64-bit integer elements.
        !! @param[in]	y	The second array of signed 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV64sV32s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV64sV32s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV64sV32s_IV64s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two unsigned 64-bit integer arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of unsigned 64-bit integer elements.
        !! @param[in]	y	The second array of unsigned 32-bit integer elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV64uV32u_IV64u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV64uV32u_IV64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV64uV32u_IV64u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two single precision (32-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The second array of single precision (32-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV32fV32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV32fV32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV32fV32f_IV32f
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of corresponding elements in two double precision (64-bit) floating-point arrays and writes the result to the first array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The first array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The second array of double precision (64-bit) floating-point elements.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV64fV64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV64fV64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)    :: y
        END FUNCTION yepCore_Max_IV64fV64f_IV64f
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of signed 8-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of signed 8-bit integer elements.
        !! @param[in]	y	The signed 8-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV8sS8s_IV8s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV8sS8s_IV8s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), VALUE                            :: y
        END FUNCTION yepCore_Max_IV8sS8s_IV8s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of unsigned 8-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of unsigned 8-bit integer elements.
        !! @param[in]	y	The unsigned 8-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV8uS8u_IV8u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV8uS8u_IV8u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT8_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                            :: length
            INTEGER(C_INT8_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT8_T), VALUE                            :: y
        END FUNCTION yepCore_Max_IV8uS8u_IV8u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of signed 16-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of signed 16-bit integer elements.
        !! @param[in]	y	The signed 16-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV16sS16s_IV16s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV16sS16s_IV16s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), VALUE                            :: y
        END FUNCTION yepCore_Max_IV16sS16s_IV16s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of unsigned 16-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of unsigned 16-bit integer elements.
        !! @param[in]	y	The unsigned 16-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV16uS16u_IV16u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV16uS16u_IV16u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT16_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT16_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT16_T), VALUE                            :: y
        END FUNCTION yepCore_Max_IV16uS16u_IV16u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of signed 32-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of signed 32-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV32sS32s_IV32s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV32sS32s_IV32s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Max_IV32sS32s_IV32s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of unsigned 32-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of unsigned 32-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV32uS32u_IV32u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV32uS32u_IV32u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT32_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Max_IV32uS32u_IV32u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of signed 64-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of signed 64-bit integer elements.
        !! @param[in]	y	The signed 32-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV64sS32s_IV64s & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV64sS32s_IV64s')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Max_IV64sS32s_IV64s
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of unsigned 64-bit integer array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of unsigned 64-bit integer elements.
        !! @param[in]	y	The unsigned 32-bit integer constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV64uS32u_IV64u & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV64uS32u_IV64u')

            USE ISO_C_BINDING, ONLY: C_INT, C_INT32_T, C_INT64_T, C_SIZE_T
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                             :: length
            INTEGER(C_INT64_T), INTENT(INOUT), DIMENSION(length) :: x
            INTEGER(C_INT32_T), VALUE                            :: y
        END FUNCTION yepCore_Max_IV64uS32u_IV64u
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of single precision (32-bit) floating-point array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of single precision (32-bit) floating-point elements.
        !! @param[in]	y	The single precision (32-bit) floating-point constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV32fS32f_IV32f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV32fS32f_IV32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_FLOAT), VALUE                            :: y
        END FUNCTION yepCore_Max_IV32fS32f_IV32f
        !> @ingroup	yepCore_Max
        !! @brief	Computes pairwise maxima of double precision (64-bit) floating-point array elements and a constant and writes the result to the same array.
        !! @warning	This version of @Yeppp does not include optimized implementations for this function
        !! @param[in,out]	x	The array of double precision (64-bit) floating-point elements.
        !! @param[in]	y	The double precision (64-bit) floating-point constant.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x argument is not naturally aligned.
        INTEGER(C_INT) FUNCTION yepCore_Max_IV64fS64f_IV64f & 
            (x, y, length) &
            BIND(C, NAME='yepCore_Max_IV64fS64f_IV64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(INOUT), DIMENSION(length) :: x
            REAL(C_DOUBLE), VALUE                            :: y
        END FUNCTION yepCore_Max_IV64fS64f_IV64f
        !> @ingroup yepCore
        !! @defgroup yepCore_Sum	Sum

        !> @ingroup	yepCore_Sum
        !! @brief	Computes the sum of single precision (32-bit) floating-point array elements.
        !! @param[in]	v	The array of elements which will be summed up.
        !! @param[out]	sum	The variable where the sum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. If @a length is zero, the computed sum will be 0.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE3</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Sum_V32f_S32f & 
            (v, sum, length) &
            BIND(C, NAME='yepCore_Sum_V32f_S32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                     :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length) :: v
            REAL(C_FLOAT), INTENT(OUT)                   :: sum
        END FUNCTION yepCore_Sum_V32f_S32f
        !> @ingroup	yepCore_Sum
        !! @brief	Computes the sum of double precision (64-bit) floating-point array elements.
        !! @param[in]	v	The array of elements which will be summed up.
        !! @param[out]	sum	The variable where the sum will be stored.
        !! @param[in]	length	Length of the array specified by @a v. If @a length is zero, the computed sum will be 0.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a sum argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_Sum_V64f_S64f & 
            (v, sum, length) &
            BIND(C, NAME='yepCore_Sum_V64f_S64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length) :: v
            REAL(C_DOUBLE), INTENT(OUT)                   :: sum
        END FUNCTION yepCore_Sum_V64f_S64f
        !> @ingroup yepCore
        !! @defgroup yepCore_SumAbs	Sum of absolute values

        !> @ingroup	yepCore_SumAbs
        !! @brief	Computes the sum of absolute values of single precision (32-bit) floating-point array elements.
        !! @param[in]	v	The array of elements whose absolute values will be summed up.
        !! @param[out]	sumAbs	The variable where the sum of absolute values will be stored.
        !! @param[in]	length	Length of the array specified by @a v. If @a length is zero, the computed sum will be 0.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a sumAbs argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2, SSE3</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_SumAbs_V32f_S32f & 
            (v, sumAbs, length) &
            BIND(C, NAME='yepCore_SumAbs_V32f_S32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                     :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length) :: v
            REAL(C_FLOAT), INTENT(OUT)                   :: sumAbs
        END FUNCTION yepCore_SumAbs_V32f_S32f
        !> @ingroup	yepCore_SumAbs
        !! @brief	Computes the sum of absolute values of double precision (64-bit) floating-point array elements.
        !! @param[in]	v	The array of elements whose absolute values will be summed up.
        !! @param[out]	sumAbs	The variable where the sum of absolute values will be stored.
        !! @param[in]	length	Length of the array specified by @a v. If @a length is zero, the computed sum will be 0.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a sumAbs argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_SumAbs_V64f_S64f & 
            (v, sumAbs, length) &
            BIND(C, NAME='yepCore_SumAbs_V64f_S64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length) :: v
            REAL(C_DOUBLE), INTENT(OUT)                   :: sumAbs
        END FUNCTION yepCore_SumAbs_V64f_S64f
        !> @ingroup yepCore
        !! @defgroup yepCore_SumSquares	Sum of squares (squared L2 norm)

        !> @ingroup	yepCore_SumSquares
        !! @brief	Computes the sum of squares of single precision (32-bit) floating-point array elements.
        !! @param[in]	v	The array of elements which will be squared (without write-back) and summed up.
        !! @param[out]	sumSquares	The variable where the sum of squares will be stored.
        !! @param[in]	length	Length of the array specified by @a v. If @a length is zero, the computed sum of squares will be 0.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a sumSquares argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE3</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_SumSquares_V32f_S32f & 
            (v, sumSquares, length) &
            BIND(C, NAME='yepCore_SumSquares_V32f_S32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                     :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length) :: v
            REAL(C_FLOAT), INTENT(OUT)                   :: sumSquares
        END FUNCTION yepCore_SumSquares_V32f_S32f
        !> @ingroup	yepCore_SumSquares
        !! @brief	Computes the sum of squares of double precision (64-bit) floating-point array elements.
        !! @param[in]	v	The array of elements which will be squared (without write-back) and summed up.
        !! @param[out]	sumSquares	The variable where the sum of squares will be stored.
        !! @param[in]	length	Length of the array specified by @a v. If @a length is zero, the computed sum of squares will be 0.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a v or @a sumSquares argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_SumSquares_V64f_S64f & 
            (v, sumSquares, length) &
            BIND(C, NAME='yepCore_SumSquares_V64f_S64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length) :: v
            REAL(C_DOUBLE), INTENT(OUT)                   :: sumSquares
        END FUNCTION yepCore_SumSquares_V64f_S64f
        !> @ingroup yepCore
        !! @defgroup yepCore_DotProduct	Dot product

        !> @ingroup	yepCore_DotProduct
        !! @brief	Computes the dot product of two vectors of single precision (32-bit) floating-point elements.
        !! @param[in]	x	The first vector of elements.
        !! @param[in]	y	The second vector of elements.
        !! @param[out]	dotProduct	The variable where the dot product value will be stored.
        !! @param[in]	length	Length of the vectors specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a dotProduct argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE3</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_DotProduct_V32fV32f_S32f & 
            (x, y, dotProduct, length) &
            BIND(C, NAME='yepCore_DotProduct_V32fV32f_S32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                     :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length) :: x
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length) :: y
            REAL(C_FLOAT), INTENT(OUT)                   :: dotProduct
        END FUNCTION yepCore_DotProduct_V32fV32f_S32f
        !> @ingroup	yepCore_DotProduct
        !! @brief	Computes the dot product of two vectors of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The first vector of elements.
        !! @param[in]	y	The second vector of elements.
        !! @param[out]	dotProduct	The variable where the dot product value will be stored.
        !! @param[in]	length	Length of the vectors specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x, @a y or @a dotProduct argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Bonnell</td><td>SSE, SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepCore_DotProduct_V64fV64f_S64f & 
            (x, y, dotProduct, length) &
            BIND(C, NAME='yepCore_DotProduct_V64fV64f_S64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                      :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length) :: x
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length) :: y
            REAL(C_DOUBLE), INTENT(OUT)                   :: dotProduct
        END FUNCTION yepCore_DotProduct_V64fV64f_S64f
    END INTERFACE
END MODULE yepCore
