!                       Yeppp! library implementation
!                   This file is auto-generated by Peach-Py,
!        Portable Efficient Assembly Code-generator in Higher-level Python,
!                  part of the Yeppp! library infrastructure
! This file is part of Yeppp! library and licensed under the New BSD license.
! See LICENSE.txt for the full text of the license.

!> @defgroup yepMath yepMath: vector mathematical functions.
MODULE yepMath
    INTERFACE
        !> @ingroup yepMath
        !! @defgroup yepMath_Log	Natural logarithm

        !> @ingroup	yepMath_Log
        !! @brief	Computes natural logarithm on an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The array of elements on which logarithm will be computed.
        !! @param[out]	y	Pointer the array where the computed logarithms will be stored.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>SSE, SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4, XOP</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bobcat</td><td>SSE, SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepMath_Log_V64f_V64f & 
            (x, y, length) &
            BIND(C, NAME='yepMath_Log_V64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepMath_Log_V64f_V64f
        !> @ingroup yepMath
        !! @defgroup yepMath_Exp	Base-e exponent

        !> @ingroup	yepMath_Exp
        !! @brief	Computes base-e exponent on an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The array of elements on which exponent will be computed.
        !! @param[out]	y	Pointer the array where the computed exponents will be stored.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD K10</td><td>CMOV, SSE, SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bobcat</td><td>CMOV, SSE, SSE2</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepMath_Exp_V64f_V64f & 
            (x, y, length) &
            BIND(C, NAME='yepMath_Exp_V64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepMath_Exp_V64f_V64f
        !> @ingroup yepMath
        !! @defgroup yepMath_Sin	Sine

        !> @ingroup	yepMath_Sin
        !! @brief	Computes sine on an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The array of elements on which sine will be computed.
        !! @param[out]	y	Pointer the array where the computed sines will be stored.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepMath_Sin_V64f_V64f & 
            (x, y, length) &
            BIND(C, NAME='yepMath_Sin_V64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepMath_Sin_V64f_V64f
        !> @ingroup yepMath
        !! @defgroup yepMath_Cos	Cosine

        !> @ingroup	yepMath_Cos
        !! @brief	Computes cosine on an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The array of elements on which cosine will be computed.
        !! @param[out]	y	Pointer the array where the computed cosines will be stored.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE, SSE2, SSE4.1</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>AVX, AVX2, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepMath_Cos_V64f_V64f & 
            (x, y, length) &
            BIND(C, NAME='yepMath_Cos_V64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepMath_Cos_V64f_V64f
        !> @ingroup yepMath
        !! @defgroup yepMath_Tan	Tangent

        !> @ingroup	yepMath_Tan
        !! @brief	Computes tangent on an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The array of elements on which tangent will be computed.
        !! @param[out]	y	Pointer the array where the computed tangents will be stored.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a x or @a y argument is not naturally aligned.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepMath_Tan_V64f_V64f & 
            (x, y, length) &
            BIND(C, NAME='yepMath_Tan_V64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                       :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)  :: x
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length) :: y
        END FUNCTION yepMath_Tan_V64f_V64f
        !> @ingroup yepMath
        !! @defgroup yepMath_EvaluatePolynomial	Polynomial evaluation

        !> @ingroup	yepMath_EvaluatePolynomial
        !! @brief	Evaluates polynomial with single precision (32-bit) floating-point coefficients on an array of single precision (32-bit) floating-point elements.
        !! @param[in]	x	The array of elements on which the polynomial will be evaluated.
        !! @param[in]	coef	The array of polynomial coefficients.
        !! @param[out]	y	Pointer the array where the result of polynomial evaluation will be stored.
        !! @param[in]	coefCount	Number of polynomial coefficients. Should equal the polynomial degree plus one.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a coef, @a x or @a y argument is not naturally aligned.
        !! @retval	3	@a coefCount argument is zero.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>SSE, AVX, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Bonnell</td><td>SSE</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, NEON</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepMath_EvaluatePolynomial_V32fV32f_V32f & 
            (coef, x, y, coefCount, length) &
            BIND(C, NAME='yepMath_EvaluatePolynomial_V32fV32f_V32f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_FLOAT
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                        :: coefCount
            INTEGER(C_SIZE_T), VALUE                        :: length
            REAL(C_FLOAT), INTENT(IN), DIMENSION(coefCount) :: coef
            REAL(C_FLOAT), INTENT(IN), DIMENSION(length)    :: x
            REAL(C_FLOAT), INTENT(OUT), DIMENSION(length)   :: y
        END FUNCTION yepMath_EvaluatePolynomial_V32fV32f_V32f
        !> @ingroup	yepMath_EvaluatePolynomial
        !! @brief	Evaluates polynomial with double precision (64-bit) floating-point coefficients on an array of double precision (64-bit) floating-point elements.
        !! @param[in]	x	The array of elements on which the polynomial will be evaluated.
        !! @param[in]	coef	The array of polynomial coefficients.
        !! @param[out]	y	Pointer the array where the result of polynomial evaluation will be stored.
        !! @param[in]	coefCount	Number of polynomial coefficients. Should equal the polynomial degree plus one.
        !! @param[in]	length	Length of the arrays specified by @a x and @a y.
        !! @retval	0	The computation finished successfully.
        !! @retval	2	@a coef, @a x or @a y argument is not naturally aligned.
        !! @retval	3	@a coefCount argument is zero.
        !! @par	Optimized implementations
        !!     		<table>
        !!     			<tr><th>Architecture</th><th>Target microarchitecture</th><th>Required instruction extensions</th></tr>
        !!     			<tr><td>x86-64</td><td>Intel Nehalem</td><td>SSE2, SSE3</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Sandy Bridge</td><td>AVX</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Haswell</td><td>SSE, AVX, FMA3</td></tr>
        !!     			<tr><td>x86-64</td><td>Intel Bonnell</td><td>SSE, SSE2</td></tr>
        !!     			<tr><td>x86-64</td><td>AMD Bulldozer</td><td>AVX, FMA4</td></tr>
        !!     			<tr><td>ARM</td><td>ARM Cortex-A9</td><td>VFP2, VFPd32</td></tr>
        !!     		</table>
        INTEGER(C_INT) FUNCTION yepMath_EvaluatePolynomial_V64fV64f_V64f & 
            (coef, x, y, coefCount, length) &
            BIND(C, NAME='yepMath_EvaluatePolynomial_V64fV64f_V64f')

            USE ISO_C_BINDING, ONLY: C_INT, C_SIZE_T, C_DOUBLE
            IMPLICIT NONE
            INTEGER(C_SIZE_T), VALUE                         :: coefCount
            INTEGER(C_SIZE_T), VALUE                         :: length
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(coefCount) :: coef
            REAL(C_DOUBLE), INTENT(IN), DIMENSION(length)    :: x
            REAL(C_DOUBLE), INTENT(OUT), DIMENSION(length)   :: y
        END FUNCTION yepMath_EvaluatePolynomial_V64fV64f_V64f
    END INTERFACE
END MODULE yepMath
