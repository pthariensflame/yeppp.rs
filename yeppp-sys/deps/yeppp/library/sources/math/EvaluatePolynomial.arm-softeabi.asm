@                       Yeppp! library implementation
@                   This file is auto-generated by Peach-Py,
@        Portable Efficient Assembly Code-generator in Higher-level Python,
@                  part of the Yeppp! library infrastructure
@ This file is part of Yeppp! library and licensed under the New BSD license.
@ See LICENSE.txt for the full text of the license.

.macro BEGIN_ARM_FUNCTION name
	.arm
	.globl \name
	.align 2
	.func \name
	.internal \name
	\name:
.endm

.macro END_ARM_FUNCTION name
	.endfunc
	.type \name, %function
	.size \name, .-\name
.endm

.section .text.CortexA9,"ax",%progbits
BEGIN_ARM_FUNCTION _yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9
	.arch armv5t
	.fpu neon
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.ENTRY:
	PUSH {r4, r5}
	VPUSH {d10, d11, d12, d13, d14, d15}
	LDR r12, [sp, #56]
	TST r1, r1
	BEQ L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_null_pointer
	TST r1, #3
	BNE L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_misaligned_pointer
	TST r2, r2
	BEQ L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_null_pointer
	TST r2, #3
	BNE L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_misaligned_pointer
	TST r12, r12
	BEQ L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_ok
	SUBS r12, r12, #24
	BLO L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.process_restore
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.process_batch:
	ADD r4, r0, r3, LSL #2
	SUB r4, r4, #4
	MOV r5, #-4
	VLD1.32 {d10[], d11[]}, [r4], r5
	VMOV q8, q5
	VMOV q9, q5
	VMOV q2, q5
	VMOV q3, q5
	VMOV q4, q5
	CMP r4, r0
	BLO L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.batch_polevl_finish
	VLD1.32 {d24[], d25[]}, [r4], r5
	VLD1.32 {d12, d13, d14, d15}, [r1]!
	VMUL.F32 q8, q8, q6
	VMUL.F32 q9, q9, q7
	VADD.F32 q8, q8, q12
	VADD.F32 q9, q9, q12
	VLD1.32 {d0, d1, d2, d3}, [r1]!
	VMUL.F32 q2, q2, q0
	VMUL.F32 q3, q3, q1
	VADD.F32 q2, q2, q12
	VADD.F32 q3, q3, q12
	VLD1.32 {d20, d21, d22, d23}, [r1]!
	VMUL.F32 q4, q4, q10
	VMUL.F32 q5, q5, q11
	VADD.F32 q4, q4, q12
	VADD.F32 q5, q5, q12
	CMP r4, r0
	BLO L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.batch_polevl_finish
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.batch_polevl_next:
	VLD1.32 {d24[], d25[]}, [r4], r5
	VMUL.F32 q8, q8, q6
	VMUL.F32 q9, q9, q7
	VADD.F32 q8, q8, q12
	VADD.F32 q9, q9, q12
	VMUL.F32 q2, q2, q0
	VMUL.F32 q3, q3, q1
	VADD.F32 q2, q2, q12
	VADD.F32 q3, q3, q12
	VMUL.F32 q4, q4, q10
	VMUL.F32 q5, q5, q11
	VADD.F32 q4, q4, q12
	VADD.F32 q5, q5, q12
	CMP r4, r0
	BHS L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.batch_polevl_next
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.batch_polevl_finish:
	VST1.32 {d16, d17, d18, d19}, [r2]!
	VST1.32 {d4, d5, d6, d7}, [r2]!
	VST1.32 {d8, d9, d10, d11}, [r2]!
	SUBS r12, r12, #24
	BHS L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.process_batch
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.process_restore:
	ADDS r12, r12, #24
	BEQ L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_ok
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.process_single:
	VLDR s0, [r1]
	ADD r1, r1, #4
	ADD r4, r0, r3, LSL #2
	SUB r4, r4, #4
	VLDR s1, [r4]
	SUB r4, r4, #4
	CMP r4, r0
	BLO L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.scalar_polevl_finish
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.scalar_polevl_next:
	VLDR s2, [r4]
	VMUL.F32 s1, s1, s0
	VADD.F32 s1, s1, s2
	SUB r4, r4, #4
	CMP r4, r0
	BHS L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.scalar_polevl_next
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.scalar_polevl_finish:
	VSTR s1, [r2]
	ADD r2, r2, #4
	SUBS r12, r12, #1
	BNE L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.process_single
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_ok:
	MOV r0, #0
	VPOP {d10, d11, d12, d13, d14, d15}
	POP {r4, r5}
	BX lr
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_null_pointer:
	MOV r0, #1
	VPOP {d10, d11, d12, d13, d14, d15}
	POP {r4, r5}
	BX lr
L_yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9.return_misaligned_pointer:
	MOV r0, #2
	VPOP {d10, d11, d12, d13, d14, d15}
	POP {r4, r5}
	BX lr
END_ARM_FUNCTION _yepMath_EvaluatePolynomial_V32fV32f_V32f_CortexA9

.section .text.CortexA9,"ax",%progbits
BEGIN_ARM_FUNCTION _yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9
	.arch armv5t
	.fpu vfpv3
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.ENTRY:
	PUSH {r3, r4}
	VPUSH {d8, d9, d10, d11, d12, d13, d14, d15}
	LDR r12, [sp, #72]
	TST r1, r1
	BEQ L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_null_pointer
	TST r1, #7
	BNE L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_misaligned_pointer
	TST r2, r2
	BEQ L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_null_pointer
	TST r2, #7
	BNE L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_misaligned_pointer
	TST r12, r12
	BEQ L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_ok
	SUBS r12, r12, #15
	BLO L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.process_restore
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.process_batch:
	ADD r4, r0, r3, LSL #3
	VLDR d29, [r4, #-8]
	SUB r4, r4, #16
	VLDM r1!, {d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14}
	VMOV.F64 d15, d29
	VMOV.F64 d16, d29
	VMOV.F64 d17, d29
	VMOV.F64 d18, d29
	VMOV.F64 d19, d29
	VMOV.F64 d20, d29
	VMOV.F64 d21, d29
	VMOV.F64 d22, d29
	VMOV.F64 d23, d29
	VMOV.F64 d24, d29
	VMOV.F64 d25, d29
	VMOV.F64 d26, d29
	VMOV.F64 d27, d29
	CMP r4, r0
	VMOV.F64 d28, d29
	BLO L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.batch_polevl_finish
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.batch_polevl_next:
	VLDR d30, [r4]
	VMUL.F64 d15, d15, d0
	SUB r4, r4, #8
	VMUL.F64 d16, d16, d1
	VMUL.F64 d17, d17, d2
	VADD.F64 d15, d15, d30
	VMUL.F64 d18, d18, d3
	VADD.F64 d16, d16, d30
	VMUL.F64 d19, d19, d4
	VADD.F64 d17, d17, d30
	VMUL.F64 d20, d20, d5
	VADD.F64 d18, d18, d30
	VMUL.F64 d21, d21, d6
	VADD.F64 d19, d19, d30
	VMUL.F64 d22, d22, d7
	VADD.F64 d20, d20, d30
	VMUL.F64 d23, d23, d8
	VADD.F64 d21, d21, d30
	VMUL.F64 d24, d24, d9
	VADD.F64 d22, d22, d30
	VMUL.F64 d25, d25, d10
	VADD.F64 d23, d23, d30
	VMUL.F64 d26, d26, d11
	VADD.F64 d24, d24, d30
	VMUL.F64 d27, d27, d12
	VADD.F64 d25, d25, d30
	VMUL.F64 d28, d28, d13
	VADD.F64 d26, d26, d30
	VMUL.F64 d29, d29, d14
	VADD.F64 d27, d27, d30
	VADD.F64 d28, d28, d30
	CMP r4, r0
	VADD.F64 d29, d29, d30
	BHS L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.batch_polevl_next
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.batch_polevl_finish:
	VSTM r2!, {d15, d16, d17, d18, d19, d20, d21, d22, d23, d24, d25, d26, d27, d28, d29}
	SUBS r12, r12, #15
	BHS L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.process_batch
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.process_restore:
	ADDS r12, r12, #15
	BEQ L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_ok
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.process_single:
	VLDR d0, [r1]
	ADD r1, r1, #8
	ADD r4, r0, r3, LSL #3
	SUB r4, r4, #8
	VLDR d1, [r4]
	SUB r4, r4, #8
	CMP r4, r0
	BLO L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.scalar_polevl_finish
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.scalar_polevl_next:
	VLDR d2, [r4]
	VMUL.F64 d1, d1, d0
	VADD.F64 d1, d1, d2
	SUB r4, r4, #8
	CMP r4, r0
	BHS L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.scalar_polevl_next
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.scalar_polevl_finish:
	VSTR d1, [r2]
	ADD r2, r2, #8
	SUBS r12, r12, #1
	BNE L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.process_single
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_ok:
	MOV r0, #0
	VPOP {d8, d9, d10, d11, d12, d13, d14, d15}
	POP {r3, r4}
	BX lr
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_null_pointer:
	MOV r0, #1
	VPOP {d8, d9, d10, d11, d12, d13, d14, d15}
	POP {r3, r4}
	BX lr
L_yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9.return_misaligned_pointer:
	MOV r0, #2
	VPOP {d8, d9, d10, d11, d12, d13, d14, d15}
	POP {r3, r4}
	BX lr
END_ARM_FUNCTION _yepMath_EvaluatePolynomial_V64fV64f_V64f_CortexA9
