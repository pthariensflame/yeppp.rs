/*
 *                       Yeppp! library implementation
 *                   This file is auto-generated by Peach-Py,
 *        Portable Efficient Assembly Code-generator in Higher-level Python,
 *                  part of the Yeppp! library infrastructure
 * This file is part of Yeppp! library and licensed under the New BSD license.
 * See LICENSE.txt for the full text of the license.
 */

#include <yepPredefines.h>
#include <yepPrivate.h>
#include <yepLibrary.h>
#include <library/functions.h>
#include <yepRandom.h>
#include <core/functions.h>
#include <yepBuiltin.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#ifdef YEP_WINDOWS_OS
	#include <windows.h>
	#define YEP_ESCAPE_NORMAL_COLOR ""
	#define YEP_ESCAPE_RED_COLOR ""
	#define YEP_ESCAPE_GREEN_COLOR ""
	#define YEP_ESCAPE_YELLOW_COLOR ""
#else
	#define YEP_ESCAPE_NORMAL_COLOR "\x1B[0m"
	#define YEP_ESCAPE_RED_COLOR "\x1B[31m"
	#define YEP_ESCAPE_GREEN_COLOR "\x1B[32m"
	#define YEP_ESCAPE_YELLOW_COLOR "\x1B[33m"
#endif

static const char* getMicroarchitectureName(YepCpuMicroarchitecture microarchitecture) {
	const YepSize bufferSize = 1024;
	static char buffer[bufferSize];
	YepSize bufferLength = bufferSize - 1;
	YepStatus status = yepLibrary_GetString(YepEnumerationCpuMicroarchitecture, microarchitecture, YepStringTypeDescription, buffer, &bufferLength);
	assert(status == YepStatusOk);
	buffer[bufferLength] = '\0';
	return buffer;
}

static void reportFailedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY);
		printf("FAILED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sFAILED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_RED_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static void reportFailedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture, float ulpError) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY);
		printf("FAILED");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
		printf(" (%f ULP)\n", ulpError);
	#else
		printf("%s (%s): %sFAILED%s (%f ULP)\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_RED_COLOR, YEP_ESCAPE_NORMAL_COLOR, ulpError);
	#endif
}

static void reportPassedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		printf("PASSED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sPASSED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_GREEN_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static void reportSkippedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		printf("SKIPPED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sSKIPPED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_YELLOW_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static Yep32s Test_Min_V8s_S8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V8s_S8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s vArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s minimum;
	Yep8s minimumInit;
	Yep8s minimumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V8s_S8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep8s); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V8s_S8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V8s_S8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V8s_S8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V8s_S8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V8u_S8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, Yep8u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V8u_S8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u vArray[1088 + (64 / sizeof(Yep8u))];
	Yep8u minimum;
	Yep8u minimumInit;
	Yep8u minimumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V8u_S8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep8u); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V8u_S8u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V8u_S8u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V8u_S8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V8u_S8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V16s_S16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V16s_S16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s vArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s minimum;
	Yep16s minimumInit;
	Yep16s minimumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V16s_S16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep16s); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V16s_S16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V16s_S16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V16s_S16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V16s_S16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V16u_S16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V16u_S16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u vArray[1088 + (64 / sizeof(Yep16u))];
	Yep16u minimum;
	Yep16u minimumInit;
	Yep16u minimumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V16u_S16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep16u); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V16u_S16u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V16u_S16u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V16u_S16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V16u_S16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32s_S32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32s_S32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s vArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s minimum;
	Yep32s minimumInit;
	Yep32s minimumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32s_S32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep32s); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V32s_S32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V32s_S32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V32s_S32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32s_S32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32u_S32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32u_S32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u vArray[1088 + (64 / sizeof(Yep32u))];
	Yep32u minimum;
	Yep32u minimumInit;
	Yep32u minimumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32u_S32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep32u); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V32u_S32u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V32u_S32u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V32u_S32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32u_S32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64s_S64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64s_S64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s vArray[1088 + (64 / sizeof(Yep64s))];
	Yep64s minimum;
	Yep64s minimumInit;
	Yep64s minimumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64s_S64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep64s); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V64s_S64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V64s_S64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V64s_S64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64s_S64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64u_S64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64u *YEP_RESTRICT, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64u_S64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u vArray[1088 + (64 / sizeof(Yep64u))];
	Yep64u minimum;
	Yep64u minimumInit;
	Yep64u minimumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64u_S64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep64u); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V64u_S64u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					if (minimum != minimumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V64u_S64u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V64u_S64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64u_S64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32f_S32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32f_S32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f vArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f minimum;
	Yep32f minimumInit;
	Yep32f minimumRef;

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32f_S32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep32f); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					const Yep32f ulpError = yepBuiltin_Abs_32f_32f(minimumRef - minimum) / yepBuiltin_Ulp_32f_32f(minimumRef);
					if (ulpError > 1000.0f) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V32f_S32f", descriptor->microarchitecture, float(ulpError));
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					const Yep32f ulpError = yepBuiltin_Abs_32f_32f(minimumRef - minimum) / yepBuiltin_Ulp_32f_32f(minimumRef);
					if (ulpError > 1000.0f) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V32f_S32f", descriptor->microarchitecture, float(ulpError));
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V32f_S32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32f_S32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64f_S64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64f_S64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f vArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f minimum;
	Yep64f minimumInit;
	Yep64f minimumRef;

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &minimumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64f_S64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep64f); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					const Yep64f ulpError = yepBuiltin_Abs_64f_64f(minimumRef - minimum) / yepBuiltin_Ulp_64f_64f(minimumRef);
					if (ulpError > 1000.0f) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V64f_S64f", descriptor->microarchitecture, float(ulpError));
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					minimumRef = minimumInit;
					status = defaultImplementation(&vArray[vOffset], &minimumRef, length);
					assert(status == YepStatusOk);

					minimum = minimumInit;
					status = descriptor->function(&vArray[vOffset], &minimum, length);
					assert(status == YepStatusOk);

					const Yep64f ulpError = yepBuiltin_Abs_64f_64f(minimumRef - minimum) / yepBuiltin_Ulp_64f_64f(minimumRef);
					if (ulpError > 1000.0f) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_V64f_S64f", descriptor->microarchitecture, float(ulpError));
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_V64f_S64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64f_S64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V8sV8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V8sV8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s minimumArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s minimumInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s minimumRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V8sV8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep8s); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V8sV8s_V8s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V8sV8s_V8s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V8sV8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V8sV8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V8uV8u_V8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, const Yep8u *YEP_RESTRICT, Yep8u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V8uV8u_V8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u yArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u minimumArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u minimumInitArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u minimumRefArray[1088 + (64 / sizeof(Yep8u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V8uV8u_V8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8u); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep8u); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V8uV8u_V8u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V8uV8u_V8u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V8uV8u_V8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V8uV8u_V8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V16sV16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V16sV16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s minimumArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s minimumInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s minimumRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V16sV16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep16s); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V16sV16s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V16sV16s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V16sV16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V16sV16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V16uV16u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, const Yep16u *YEP_RESTRICT, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V16uV16u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u yArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u minimumArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u minimumInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u minimumRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V16uV16u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16u); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep16u); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V16uV16u_V16u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V16uV16u_V16u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V16uV16u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V16uV16u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32sV32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32sV32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s minimumArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s minimumInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s minimumRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32sV32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep32s); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V32sV32s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V32sV32s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V32sV32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32sV32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32uV32u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32uV32u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u minimumArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u minimumInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u minimumRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32uV32u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep32u); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V32uV32u_V32u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V32uV32u_V32u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V32uV32u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32uV32u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64sV32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64sV32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep64s minimumArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s minimumInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s minimumRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64sV32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep64s); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V64sV32s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V64sV32s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V64sV32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64sV32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64uV32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64uV32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u xArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep64u minimumArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u minimumInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u minimumRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64uV32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep64u); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V64uV32u_V64u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V64uV32u_V64u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V64uV32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64uV32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32fV32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, const Yep32f *YEP_RESTRICT, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32fV32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f minimumArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f minimumInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f minimumRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32fV32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep32f); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(minimumArray); i++) {
								const Yep32f ulpError = yepBuiltin_Abs_32f_32f(minimumRefArray[i] - minimumArray[i]) / yepBuiltin_Ulp_32f_32f(minimumRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Min_V32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(minimumArray); i++) {
								const Yep32f ulpError = yepBuiltin_Abs_32f_32f(minimumRefArray[i] - minimumArray[i]) / yepBuiltin_Ulp_32f_32f(minimumRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Min_V32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V32fV32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32fV32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64fV64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, const Yep64f *YEP_RESTRICT, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64fV64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f minimumArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f minimumInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f minimumRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64fV64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep64f); minimumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(minimumArray); i++) {
								const Yep64f ulpError = yepBuiltin_Abs_64f_64f(minimumRefArray[i] - minimumArray[i]) / yepBuiltin_Ulp_64f_64f(minimumRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Min_V64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &minimumRefArray[minimumOffset], length);
							assert(status == YepStatusOk);

							memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &minimumArray[minimumOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(minimumArray); i++) {
								const Yep64f ulpError = yepBuiltin_Abs_64f_64f(minimumRefArray[i] - minimumArray[i]) / yepBuiltin_Ulp_64f_64f(minimumRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Min_V64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V64fV64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64fV64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V8sS8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V8sS8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;
	YEP_ALIGN(64) Yep8s minimumArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s minimumInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s minimumRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V8sS8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep8s); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V8sS8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V8sS8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V8sS8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V8sS8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V8uS8u_V8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, Yep8u, Yep8u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V8uS8u_V8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	Yep8u y;
	YEP_ALIGN(64) Yep8u minimumArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u minimumInitArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u minimumRefArray[1088 + (64 / sizeof(Yep8u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V8uS8u_V8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep8u); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V8uS8u_V8u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V8uS8u_V8u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V8uS8u_V8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V8uS8u_V8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V16sS16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V16sS16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;
	YEP_ALIGN(64) Yep16s minimumArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s minimumInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s minimumRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V16sS16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep16s); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V16sS16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V16sS16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V16sS16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V16sS16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V16uS16u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, Yep16u, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V16uS16u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	Yep16u y;
	YEP_ALIGN(64) Yep16u minimumArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u minimumInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u minimumRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V16uS16u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep16u); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V16uS16u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V16uS16u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V16uS16u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V16uS16u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32sS32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32sS32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;
	YEP_ALIGN(64) Yep32s minimumArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s minimumInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s minimumRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32sS32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep32s); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V32sS32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V32sS32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V32sS32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32sS32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32uS32u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, Yep32u, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32uS32u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	Yep32u y;
	YEP_ALIGN(64) Yep32u minimumArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u minimumInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u minimumRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32uS32u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep32u); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V32uS32u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V32uS32u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V32uS32u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32uS32u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64sS32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, Yep32s, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64sS32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	Yep32s y;
	YEP_ALIGN(64) Yep64s minimumArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s minimumInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s minimumRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64sS32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep64s); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V64sS32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V64sS32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V64sS32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64sS32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64uS32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64u *YEP_RESTRICT, Yep32u, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64uS32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u xArray[1088 + (64 / sizeof(Yep64u))];
	Yep32u y;
	YEP_ALIGN(64) Yep64u minimumArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u minimumInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u minimumRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64uS32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64u); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep64u); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V64uS32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(minimumArray, minimumRefArray, sizeof(minimumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_V64uS32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V64uS32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64uS32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V32fS32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, Yep32f, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V32fS32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f y;
	YEP_ALIGN(64) Yep32f minimumArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f minimumInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f minimumRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V32fS32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep32f); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(minimumArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(minimumRefArray[i] - minimumArray[i]) / yepBuiltin_Ulp_32f_32f(minimumRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V32fS32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(minimumArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(minimumRefArray[i] - minimumArray[i]) / yepBuiltin_Ulp_32f_32f(minimumRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V32fS32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V32fS32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V32fS32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_V64fS64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, Yep64f, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_V64fS64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f y;
	YEP_ALIGN(64) Yep64f minimumArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f minimumInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f minimumRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, minimumInitArray, YEP_COUNT_OF(minimumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_V64fS64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize minimumOffset = 0; minimumOffset < 64 / sizeof(Yep64f); minimumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(minimumArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(minimumRefArray[i] - minimumArray[i]) / yepBuiltin_Ulp_64f_64f(minimumRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V64fS64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(minimumRefArray, minimumInitArray, sizeof(minimumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &minimumRefArray[minimumOffset], length);
						assert(status == YepStatusOk);

						memcpy(minimumArray, minimumInitArray, sizeof(minimumArray));
						status = descriptor->function(&xArray[xOffset], y, &minimumArray[minimumOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(minimumArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(minimumRefArray[i] - minimumArray[i]) / yepBuiltin_Ulp_64f_64f(minimumRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_V64fS64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_V64fS64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_V64fS64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV8sV8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV8sV8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xRefArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV8sV8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV8sV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV8sV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV8sV8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV8sV8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV8uV8u_IV8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8u *YEP_RESTRICT, const Yep8u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV8uV8u_IV8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u xInitArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u xRefArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u yArray[1088 + (64 / sizeof(Yep8u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV8uV8u_IV8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8u); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV8uV8u_IV8u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV8uV8u_IV8u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV8uV8u_IV8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV8uV8u_IV8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV16sV16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV16sV16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xRefArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV16sV16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV16sV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV16sV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV16sV16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV16sV16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV16uV16u_IV16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16u *YEP_RESTRICT, const Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV16uV16u_IV16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u xInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u xRefArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u yArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV16uV16u_IV16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16u); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV16uV16u_IV16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV16uV16u_IV16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV16uV16u_IV16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV16uV16u_IV16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV32sV32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV32sV32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xRefArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV32sV32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV32sV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV32sV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV32sV32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV32sV32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV32uV32u_IV32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV32uV32u_IV32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u xInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u xRefArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV32uV32u_IV32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV32uV32u_IV32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV32uV32u_IV32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV32uV32u_IV32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV32uV32u_IV32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV64sV32s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV64sV32s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xRefArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV64sV32s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV64sV32s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV64sV32s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV64sV32s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV64sV32s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV64uV32u_IV64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV64uV32u_IV64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u xArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u xInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u xRefArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV64uV32u_IV64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV64uV32u_IV64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV64uV32u_IV64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV64uV32u_IV64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV64uV32u_IV64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV32fV32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f *YEP_RESTRICT, const Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV32fV32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xRefArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV32fV32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_IV32fV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_IV32fV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV32fV32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV32fV32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV64fV64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f *YEP_RESTRICT, const Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV64fV64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xRefArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV64fV64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_IV64fV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Min_IV64fV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV64fV64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV64fV64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV8sS8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s *YEP_RESTRICT, Yep8s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV8sS8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xRefArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV8sS8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV8sS8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV8sS8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_IV8sS8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV8sS8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV8uS8u_IV8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8u *YEP_RESTRICT, Yep8u, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV8uS8u_IV8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u xInitArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u xRefArray[1088 + (64 / sizeof(Yep8u))];
	Yep8u y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV8uS8u_IV8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV8uS8u_IV8u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV8uS8u_IV8u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_IV8uS8u_IV8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV8uS8u_IV8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV16sS16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s *YEP_RESTRICT, Yep16s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV16sS16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xRefArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV16sS16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV16sS16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV16sS16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_IV16sS16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV16sS16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV16uS16u_IV16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16u *YEP_RESTRICT, Yep16u, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV16uS16u_IV16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u xInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u xRefArray[1088 + (64 / sizeof(Yep16u))];
	Yep16u y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV16uS16u_IV16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV16uS16u_IV16u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV16uS16u_IV16u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_IV16uS16u_IV16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV16uS16u_IV16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV32sS32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s *YEP_RESTRICT, Yep32s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV32sS32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xRefArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV32sS32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV32sS32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV32sS32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_IV32sS32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV32sS32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV32uS32u_IV32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32u *YEP_RESTRICT, Yep32u, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV32uS32u_IV32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u xInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u xRefArray[1088 + (64 / sizeof(Yep32u))];
	Yep32u y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV32uS32u_IV32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV32uS32u_IV32u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV32uS32u_IV32u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_IV32uS32u_IV32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV32uS32u_IV32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV64sS32s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s *YEP_RESTRICT, Yep32s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV64sS32s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xRefArray[1088 + (64 / sizeof(Yep64s))];
	Yep32s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV64sS32s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV64sS32s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV64sS32s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_IV64sS32s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV64sS32s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV64uS32u_IV64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64u *YEP_RESTRICT, Yep32u, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV64uS32u_IV64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u xArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u xInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u xRefArray[1088 + (64 / sizeof(Yep64u))];
	Yep32u y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV64uS32u_IV64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64u); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV64uS32u_IV64u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Min_IV64uS32u_IV64u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Min_IV64uS32u_IV64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV64uS32u_IV64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV32fS32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f *YEP_RESTRICT, Yep32f, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV32fS32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xRefArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f y;

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV32fS32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV32fS32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV32fS32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV32fS32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV32fS32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Min_IV64fS64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f *YEP_RESTRICT, Yep64f, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Min_IV64fS64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xRefArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f y;

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Min_IV64fS64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV64fS64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Min_IV64fS64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Min_IV64fS64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Min_IV64fS64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

int main(int argc, char** argv) {
	YepBoolean testMin_V8s_S8s = YepBooleanFalse;
	YepBoolean testMin_V8u_S8u = YepBooleanFalse;
	YepBoolean testMin_V16s_S16s = YepBooleanFalse;
	YepBoolean testMin_V16u_S16u = YepBooleanFalse;
	YepBoolean testMin_V32s_S32s = YepBooleanFalse;
	YepBoolean testMin_V32u_S32u = YepBooleanFalse;
	YepBoolean testMin_V64s_S64s = YepBooleanFalse;
	YepBoolean testMin_V64u_S64u = YepBooleanFalse;
	YepBoolean testMin_V32f_S32f = YepBooleanFalse;
	YepBoolean testMin_V64f_S64f = YepBooleanFalse;
	YepBoolean testMin_V8sV8s_V8s = YepBooleanFalse;
	YepBoolean testMin_V8uV8u_V8u = YepBooleanFalse;
	YepBoolean testMin_V16sV16s_V16s = YepBooleanFalse;
	YepBoolean testMin_V16uV16u_V16u = YepBooleanFalse;
	YepBoolean testMin_V32sV32s_V32s = YepBooleanFalse;
	YepBoolean testMin_V32uV32u_V32u = YepBooleanFalse;
	YepBoolean testMin_V64sV32s_V64s = YepBooleanFalse;
	YepBoolean testMin_V64uV32u_V64u = YepBooleanFalse;
	YepBoolean testMin_V32fV32f_V32f = YepBooleanFalse;
	YepBoolean testMin_V64fV64f_V64f = YepBooleanFalse;
	YepBoolean testMin_V8sS8s_V8s = YepBooleanFalse;
	YepBoolean testMin_V8uS8u_V8u = YepBooleanFalse;
	YepBoolean testMin_V16sS16s_V16s = YepBooleanFalse;
	YepBoolean testMin_V16uS16u_V16u = YepBooleanFalse;
	YepBoolean testMin_V32sS32s_V32s = YepBooleanFalse;
	YepBoolean testMin_V32uS32u_V32u = YepBooleanFalse;
	YepBoolean testMin_V64sS32s_V64s = YepBooleanFalse;
	YepBoolean testMin_V64uS32u_V64u = YepBooleanFalse;
	YepBoolean testMin_V32fS32f_V32f = YepBooleanFalse;
	YepBoolean testMin_V64fS64f_V64f = YepBooleanFalse;
	YepBoolean testMin_IV8sV8s_IV8s = YepBooleanFalse;
	YepBoolean testMin_IV8uV8u_IV8u = YepBooleanFalse;
	YepBoolean testMin_IV16sV16s_IV16s = YepBooleanFalse;
	YepBoolean testMin_IV16uV16u_IV16u = YepBooleanFalse;
	YepBoolean testMin_IV32sV32s_IV32s = YepBooleanFalse;
	YepBoolean testMin_IV32uV32u_IV32u = YepBooleanFalse;
	YepBoolean testMin_IV64sV32s_IV64s = YepBooleanFalse;
	YepBoolean testMin_IV64uV32u_IV64u = YepBooleanFalse;
	YepBoolean testMin_IV32fV32f_IV32f = YepBooleanFalse;
	YepBoolean testMin_IV64fV64f_IV64f = YepBooleanFalse;
	YepBoolean testMin_IV8sS8s_IV8s = YepBooleanFalse;
	YepBoolean testMin_IV8uS8u_IV8u = YepBooleanFalse;
	YepBoolean testMin_IV16sS16s_IV16s = YepBooleanFalse;
	YepBoolean testMin_IV16uS16u_IV16u = YepBooleanFalse;
	YepBoolean testMin_IV32sS32s_IV32s = YepBooleanFalse;
	YepBoolean testMin_IV32uS32u_IV32u = YepBooleanFalse;
	YepBoolean testMin_IV64sS32s_IV64s = YepBooleanFalse;
	YepBoolean testMin_IV64uS32u_IV64u = YepBooleanFalse;
	YepBoolean testMin_IV32fS32f_IV32f = YepBooleanFalse;
	YepBoolean testMin_IV64fS64f_IV64f = YepBooleanFalse;
	if (argc == 1) {
		/* No tests specified: run all tests*/
		testMin_V8s_S8s = YepBooleanTrue;
		testMin_V8u_S8u = YepBooleanTrue;
		testMin_V16s_S16s = YepBooleanTrue;
		testMin_V16u_S16u = YepBooleanTrue;
		testMin_V32s_S32s = YepBooleanTrue;
		testMin_V32u_S32u = YepBooleanTrue;
		testMin_V64s_S64s = YepBooleanTrue;
		testMin_V64u_S64u = YepBooleanTrue;
		testMin_V32f_S32f = YepBooleanTrue;
		testMin_V64f_S64f = YepBooleanTrue;
		testMin_V8sV8s_V8s = YepBooleanTrue;
		testMin_V8uV8u_V8u = YepBooleanTrue;
		testMin_V16sV16s_V16s = YepBooleanTrue;
		testMin_V16uV16u_V16u = YepBooleanTrue;
		testMin_V32sV32s_V32s = YepBooleanTrue;
		testMin_V32uV32u_V32u = YepBooleanTrue;
		testMin_V64sV32s_V64s = YepBooleanTrue;
		testMin_V64uV32u_V64u = YepBooleanTrue;
		testMin_V32fV32f_V32f = YepBooleanTrue;
		testMin_V64fV64f_V64f = YepBooleanTrue;
		testMin_V8sS8s_V8s = YepBooleanTrue;
		testMin_V8uS8u_V8u = YepBooleanTrue;
		testMin_V16sS16s_V16s = YepBooleanTrue;
		testMin_V16uS16u_V16u = YepBooleanTrue;
		testMin_V32sS32s_V32s = YepBooleanTrue;
		testMin_V32uS32u_V32u = YepBooleanTrue;
		testMin_V64sS32s_V64s = YepBooleanTrue;
		testMin_V64uS32u_V64u = YepBooleanTrue;
		testMin_V32fS32f_V32f = YepBooleanTrue;
		testMin_V64fS64f_V64f = YepBooleanTrue;
		testMin_IV8sV8s_IV8s = YepBooleanTrue;
		testMin_IV8uV8u_IV8u = YepBooleanTrue;
		testMin_IV16sV16s_IV16s = YepBooleanTrue;
		testMin_IV16uV16u_IV16u = YepBooleanTrue;
		testMin_IV32sV32s_IV32s = YepBooleanTrue;
		testMin_IV32uV32u_IV32u = YepBooleanTrue;
		testMin_IV64sV32s_IV64s = YepBooleanTrue;
		testMin_IV64uV32u_IV64u = YepBooleanTrue;
		testMin_IV32fV32f_IV32f = YepBooleanTrue;
		testMin_IV64fV64f_IV64f = YepBooleanTrue;
		testMin_IV8sS8s_IV8s = YepBooleanTrue;
		testMin_IV8uS8u_IV8u = YepBooleanTrue;
		testMin_IV16sS16s_IV16s = YepBooleanTrue;
		testMin_IV16uS16u_IV16u = YepBooleanTrue;
		testMin_IV32sS32s_IV32s = YepBooleanTrue;
		testMin_IV32uS32u_IV32u = YepBooleanTrue;
		testMin_IV64sS32s_IV64s = YepBooleanTrue;
		testMin_IV64uS32u_IV64u = YepBooleanTrue;
		testMin_IV32fS32f_IV32f = YepBooleanTrue;
		testMin_IV64fS64f_IV64f = YepBooleanTrue;
	} else {
		/* Some tests specified: run only specified tests*/
		for (int i = 1; i < argc; i++) {
			if (strcmp(argv[i], "V8s_S8s") == 0) {
				testMin_V8s_S8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8u_S8u") == 0) {
				testMin_V8u_S8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16s_S16s") == 0) {
				testMin_V16s_S16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16u_S16u") == 0) {
				testMin_V16u_S16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32s_S32s") == 0) {
				testMin_V32s_S32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32u_S32u") == 0) {
				testMin_V32u_S32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64s_S64s") == 0) {
				testMin_V64s_S64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64u_S64u") == 0) {
				testMin_V64u_S64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32f_S32f") == 0) {
				testMin_V32f_S32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64f_S64f") == 0) {
				testMin_V64f_S64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sV8s_V8s") == 0) {
				testMin_V8sV8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8uV8u_V8u") == 0) {
				testMin_V8uV8u_V8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sV16s_V16s") == 0) {
				testMin_V16sV16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16uV16u_V16u") == 0) {
				testMin_V16uV16u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sV32s_V32s") == 0) {
				testMin_V32sV32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32uV32u_V32u") == 0) {
				testMin_V32uV32u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sV32s_V64s") == 0) {
				testMin_V64sV32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64uV32u_V64u") == 0) {
				testMin_V64uV32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fV32f_V32f") == 0) {
				testMin_V32fV32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fV64f_V64f") == 0) {
				testMin_V64fV64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sS8s_V8s") == 0) {
				testMin_V8sS8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8uS8u_V8u") == 0) {
				testMin_V8uS8u_V8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sS16s_V16s") == 0) {
				testMin_V16sS16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16uS16u_V16u") == 0) {
				testMin_V16uS16u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sS32s_V32s") == 0) {
				testMin_V32sS32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32uS32u_V32u") == 0) {
				testMin_V32uS32u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sS32s_V64s") == 0) {
				testMin_V64sS32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64uS32u_V64u") == 0) {
				testMin_V64uS32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fS32f_V32f") == 0) {
				testMin_V32fS32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fS64f_V64f") == 0) {
				testMin_V64fS64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8sV8s_IV8s") == 0) {
				testMin_IV8sV8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8uV8u_IV8u") == 0) {
				testMin_IV8uV8u_IV8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16sV16s_IV16s") == 0) {
				testMin_IV16sV16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16uV16u_IV16u") == 0) {
				testMin_IV16uV16u_IV16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32sV32s_IV32s") == 0) {
				testMin_IV32sV32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32uV32u_IV32u") == 0) {
				testMin_IV32uV32u_IV32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64sV32s_IV64s") == 0) {
				testMin_IV64sV32s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64uV32u_IV64u") == 0) {
				testMin_IV64uV32u_IV64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32fV32f_IV32f") == 0) {
				testMin_IV32fV32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64fV64f_IV64f") == 0) {
				testMin_IV64fV64f_IV64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8sS8s_IV8s") == 0) {
				testMin_IV8sS8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8uS8u_IV8u") == 0) {
				testMin_IV8uS8u_IV8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16sS16s_IV16s") == 0) {
				testMin_IV16sS16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16uS16u_IV16u") == 0) {
				testMin_IV16uS16u_IV16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32sS32s_IV32s") == 0) {
				testMin_IV32sS32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32uS32u_IV32u") == 0) {
				testMin_IV32uS32u_IV32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64sS32s_IV64s") == 0) {
				testMin_IV64sS32s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64uS32u_IV64u") == 0) {
				testMin_IV64uS32u_IV64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32fS32f_IV32f") == 0) {
				testMin_IV32fS32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64fS64f_IV64f") == 0) {
				testMin_IV64fS64f_IV64f = YepBooleanTrue;
			} else {
				fprintf(stderr, "Unknown function name \"%s\"", argv[i]);
				return 1;
			}
		}
	}
	YepStatus status = _yepLibrary_InitCpuInfo();
	assert(status == YepStatusOk);

	Yep64u supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures;
	status = yepLibrary_GetCpuIsaFeatures(&supportedIsaFeatures);
	assert(status == YepStatusOk);
	status = yepLibrary_GetCpuSimdFeatures(&supportedSimdFeatures);
	assert(status == YepStatusOk);
	status = yepLibrary_GetCpuSystemFeatures(&supportedSystemFeatures);
	assert(status == YepStatusOk);

	Yep32s failedTests = 0;
	if YEP_LIKELY(testMin_V8s_S8s)
		failedTests += Test_Min_V8s_S8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V8u_S8u)
		failedTests += Test_Min_V8u_S8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V16s_S16s)
		failedTests += Test_Min_V16s_S16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V16u_S16u)
		failedTests += Test_Min_V16u_S16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32s_S32s)
		failedTests += Test_Min_V32s_S32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32u_S32u)
		failedTests += Test_Min_V32u_S32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64s_S64s)
		failedTests += Test_Min_V64s_S64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64u_S64u)
		failedTests += Test_Min_V64u_S64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32f_S32f)
		failedTests += Test_Min_V32f_S32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64f_S64f)
		failedTests += Test_Min_V64f_S64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V8sV8s_V8s)
		failedTests += Test_Min_V8sV8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V8uV8u_V8u)
		failedTests += Test_Min_V8uV8u_V8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V16sV16s_V16s)
		failedTests += Test_Min_V16sV16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V16uV16u_V16u)
		failedTests += Test_Min_V16uV16u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32sV32s_V32s)
		failedTests += Test_Min_V32sV32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32uV32u_V32u)
		failedTests += Test_Min_V32uV32u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64sV32s_V64s)
		failedTests += Test_Min_V64sV32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64uV32u_V64u)
		failedTests += Test_Min_V64uV32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32fV32f_V32f)
		failedTests += Test_Min_V32fV32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64fV64f_V64f)
		failedTests += Test_Min_V64fV64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V8sS8s_V8s)
		failedTests += Test_Min_V8sS8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V8uS8u_V8u)
		failedTests += Test_Min_V8uS8u_V8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V16sS16s_V16s)
		failedTests += Test_Min_V16sS16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V16uS16u_V16u)
		failedTests += Test_Min_V16uS16u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32sS32s_V32s)
		failedTests += Test_Min_V32sS32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32uS32u_V32u)
		failedTests += Test_Min_V32uS32u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64sS32s_V64s)
		failedTests += Test_Min_V64sS32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64uS32u_V64u)
		failedTests += Test_Min_V64uS32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V32fS32f_V32f)
		failedTests += Test_Min_V32fS32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_V64fS64f_V64f)
		failedTests += Test_Min_V64fS64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV8sV8s_IV8s)
		failedTests += Test_Min_IV8sV8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV8uV8u_IV8u)
		failedTests += Test_Min_IV8uV8u_IV8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV16sV16s_IV16s)
		failedTests += Test_Min_IV16sV16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV16uV16u_IV16u)
		failedTests += Test_Min_IV16uV16u_IV16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV32sV32s_IV32s)
		failedTests += Test_Min_IV32sV32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV32uV32u_IV32u)
		failedTests += Test_Min_IV32uV32u_IV32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV64sV32s_IV64s)
		failedTests += Test_Min_IV64sV32s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV64uV32u_IV64u)
		failedTests += Test_Min_IV64uV32u_IV64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV32fV32f_IV32f)
		failedTests += Test_Min_IV32fV32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV64fV64f_IV64f)
		failedTests += Test_Min_IV64fV64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV8sS8s_IV8s)
		failedTests += Test_Min_IV8sS8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV8uS8u_IV8u)
		failedTests += Test_Min_IV8uS8u_IV8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV16sS16s_IV16s)
		failedTests += Test_Min_IV16sS16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV16uS16u_IV16u)
		failedTests += Test_Min_IV16uS16u_IV16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV32sS32s_IV32s)
		failedTests += Test_Min_IV32sS32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV32uS32u_IV32u)
		failedTests += Test_Min_IV32uS32u_IV32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV64sS32s_IV64s)
		failedTests += Test_Min_IV64sS32s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV64uS32u_IV64u)
		failedTests += Test_Min_IV64uS32u_IV64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV32fS32f_IV32f)
		failedTests += Test_Min_IV32fS32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMin_IV64fS64f_IV64f)
		failedTests += Test_Min_IV64fS64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	return failedTests;
}
