/*
 *                       Yeppp! library implementation
 *                   This file is auto-generated by Peach-Py,
 *        Portable Efficient Assembly Code-generator in Higher-level Python,
 *                  part of the Yeppp! library infrastructure
 * This file is part of Yeppp! library and licensed under the New BSD license.
 * See LICENSE.txt for the full text of the license.
 */

#include <yepPredefines.h>
#include <yepPrivate.h>
#include <yepLibrary.h>
#include <library/functions.h>
#include <yepRandom.h>
#include <core/functions.h>
#include <yepBuiltin.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#ifdef YEP_WINDOWS_OS
	#include <windows.h>
	#define YEP_ESCAPE_NORMAL_COLOR ""
	#define YEP_ESCAPE_RED_COLOR ""
	#define YEP_ESCAPE_GREEN_COLOR ""
	#define YEP_ESCAPE_YELLOW_COLOR ""
#else
	#define YEP_ESCAPE_NORMAL_COLOR "\x1B[0m"
	#define YEP_ESCAPE_RED_COLOR "\x1B[31m"
	#define YEP_ESCAPE_GREEN_COLOR "\x1B[32m"
	#define YEP_ESCAPE_YELLOW_COLOR "\x1B[33m"
#endif

static const char* getMicroarchitectureName(YepCpuMicroarchitecture microarchitecture) {
	const YepSize bufferSize = 1024;
	static char buffer[bufferSize];
	YepSize bufferLength = bufferSize - 1;
	YepStatus status = yepLibrary_GetString(YepEnumerationCpuMicroarchitecture, microarchitecture, YepStringTypeDescription, buffer, &bufferLength);
	assert(status == YepStatusOk);
	buffer[bufferLength] = '\0';
	return buffer;
}

static void reportFailedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY);
		printf("FAILED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sFAILED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_RED_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static void reportFailedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture, float ulpError) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY);
		printf("FAILED");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
		printf(" (%f ULP)\n", ulpError);
	#else
		printf("%s (%s): %sFAILED%s (%f ULP)\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_RED_COLOR, YEP_ESCAPE_NORMAL_COLOR, ulpError);
	#endif
}

static void reportPassedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		printf("PASSED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sPASSED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_GREEN_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static void reportSkippedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		printf("SKIPPED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sSKIPPED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_YELLOW_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static Yep32s Test_Multiply_V8sV8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V8sV8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s productArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s productInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s productRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V8sV8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep8s); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V8sV8s_V8s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V8sV8s_V8s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V8sV8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V8sV8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V8sV8s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V8sV8s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep16s productArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V8sV8s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep16s); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V8sV8s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V8sV8s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V8sV8s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V8sV8s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V8uV8u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, const Yep8u *YEP_RESTRICT, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V8uV8u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u yArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep16u productArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u productInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u productRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V8uV8u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8u); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep16u); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V8uV8u_V16u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V8uV8u_V16u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V8uV8u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V8uV8u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V16sV16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V16sV16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V16sV16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep16s); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V16sV16s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V16sV16s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V16sV16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V16sV16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V16sV16s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V16sV16s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep32s productArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V16sV16s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep32s); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V16sV16s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V16sV16s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V16sV16s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V16sV16s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V16uV16u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, const Yep16u *YEP_RESTRICT, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V16uV16u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u yArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep32u productArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u productInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u productRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V16uV16u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16u); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep32u); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V16uV16u_V32u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V16uV16u_V32u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V16uV16u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V16uV16u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V32sV32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V32sV32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V32sV32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep32s); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V32sV32s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V32sV32s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V32sV32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V32sV32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V32sV32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V32sV32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep64s productArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V32sV32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep64s); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V32sV32s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V32sV32s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V32sV32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V32sV32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V32uV32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V32uV32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep64u productArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u productInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u productRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V32uV32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep64u); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V32uV32u_V64u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V32uV32u_V64u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V32uV32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V32uV32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V64sV64s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, const Yep64s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V64sV64s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V64sV64s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64s); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep64s); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V64sV64s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V64sV64s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V64sV64s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V64sV64s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V32fV32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, const Yep32f *YEP_RESTRICT, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V32fV32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f productArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f productInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f productRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V32fV32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep32f); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(productArray); i++) {
								const Yep32f ulpError = yepBuiltin_Abs_32f_32f(productRefArray[i] - productArray[i]) / yepBuiltin_Ulp_32f_32f(productRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Multiply_V32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(productArray); i++) {
								const Yep32f ulpError = yepBuiltin_Abs_32f_32f(productRefArray[i] - productArray[i]) / yepBuiltin_Ulp_32f_32f(productRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Multiply_V32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V32fV32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V32fV32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V64fV64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, const Yep64f *YEP_RESTRICT, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V64fV64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f productArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f productInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f productRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V64fV64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep64f); productOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(productArray); i++) {
								const Yep64f ulpError = yepBuiltin_Abs_64f_64f(productRefArray[i] - productArray[i]) / yepBuiltin_Ulp_64f_64f(productRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Multiply_V64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(productRefArray, productInitArray, sizeof(productRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &productRefArray[productOffset], length);
							assert(status == YepStatusOk);

							memcpy(productArray, productInitArray, sizeof(productArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &productArray[productOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(productArray); i++) {
								const Yep64f ulpError = yepBuiltin_Abs_64f_64f(productRefArray[i] - productArray[i]) / yepBuiltin_Ulp_64f_64f(productRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Multiply_V64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V64fV64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V64fV64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V8sS8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V8sS8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;
	YEP_ALIGN(64) Yep8s productArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s productInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s productRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V8sS8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep8s); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V8sS8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V8sS8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V8sS8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V8sS8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V8sS8s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V8sS8s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;
	YEP_ALIGN(64) Yep16s productArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V8sS8s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep16s); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V8sS8s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V8sS8s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V8sS8s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V8sS8s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V8uS8u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, Yep8u, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V8uS8u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	Yep8u y;
	YEP_ALIGN(64) Yep16u productArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u productInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u productRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V8uS8u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep16u); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V8uS8u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V8uS8u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V8uS8u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V8uS8u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V16sS16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V16sS16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;
	YEP_ALIGN(64) Yep16s productArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s productRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V16sS16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep16s); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V16sS16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V16sS16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V16sS16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V16sS16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V16sS16s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V16sS16s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;
	YEP_ALIGN(64) Yep32s productArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V16sS16s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep32s); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V16sS16s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V16sS16s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V16sS16s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V16sS16s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V16uS16u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, Yep16u, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V16uS16u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	Yep16u y;
	YEP_ALIGN(64) Yep32u productArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u productInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u productRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V16uS16u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep32u); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V16uS16u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V16uS16u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V16uS16u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V16uS16u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V32sS32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V32sS32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;
	YEP_ALIGN(64) Yep32s productArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s productRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V32sS32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep32s); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V32sS32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V32sS32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V32sS32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V32sS32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V32sS32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V32sS32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;
	YEP_ALIGN(64) Yep64s productArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V32sS32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep64s); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V32sS32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V32sS32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V32sS32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V32sS32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V32uS32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, Yep32u, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V32uS32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	Yep32u y;
	YEP_ALIGN(64) Yep64u productArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u productInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u productRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V32uS32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep64u); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V32uS32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V32uS32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V32uS32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V32uS32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V64sS64s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, Yep64s, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V64sS64s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	Yep64s y;
	YEP_ALIGN(64) Yep64s productArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s productRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V64sS64s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep64s); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V64sS64s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(productArray, productRefArray, sizeof(productArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_V64sS64s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V64sS64s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V64sS64s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V32fS32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, Yep32f, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V32fS32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f y;
	YEP_ALIGN(64) Yep32f productArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f productInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f productRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V32fS32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep32f); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(productArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(productRefArray[i] - productArray[i]) / yepBuiltin_Ulp_32f_32f(productRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V32fS32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(productArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(productRefArray[i] - productArray[i]) / yepBuiltin_Ulp_32f_32f(productRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V32fS32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V32fS32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V32fS32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_V64fS64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, Yep64f, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_V64fS64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f y;
	YEP_ALIGN(64) Yep64f productArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f productInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f productRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, productInitArray, YEP_COUNT_OF(productInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_V64fS64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize productOffset = 0; productOffset < 64 / sizeof(Yep64f); productOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(productArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(productRefArray[i] - productArray[i]) / yepBuiltin_Ulp_64f_64f(productRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V64fS64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(productRefArray, productInitArray, sizeof(productRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &productRefArray[productOffset], length);
						assert(status == YepStatusOk);

						memcpy(productArray, productInitArray, sizeof(productArray));
						status = descriptor->function(&xArray[xOffset], y, &productArray[productOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(productArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(productRefArray[i] - productArray[i]) / yepBuiltin_Ulp_64f_64f(productRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_V64fS64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_V64fS64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_V64fS64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV8sV8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV8sV8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xRefArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV8sV8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV8sV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV8sV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV8sV8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV8sV8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV16sV16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV16sV16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xRefArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV16sV16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV16sV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV16sV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV16sV16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV16sV16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV32sV32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV32sV32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xRefArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV32sV32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV32sV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV32sV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV32sV32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV32sV32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV64sV64s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s *YEP_RESTRICT, const Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV64sV64s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xRefArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV64sV64s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV64sV64s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV64sV64s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV64sV64s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV64sV64s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV32fV32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f *YEP_RESTRICT, const Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV32fV32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xRefArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV32fV32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_IV32fV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_IV32fV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV32fV32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV32fV32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV64fV64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f *YEP_RESTRICT, const Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV64fV64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xRefArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV64fV64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_IV64fV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Multiply_IV64fV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV64fV64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV64fV64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV8sS8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s *YEP_RESTRICT, Yep8s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV8sS8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xRefArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV8sS8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Multiply_IV8sS8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Multiply_IV8sS8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV8sS8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV8sS8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV16sS16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s *YEP_RESTRICT, Yep16s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV16sS16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xRefArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV16sS16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Multiply_IV16sS16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Multiply_IV16sS16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV16sS16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV16sS16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV32sS32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s *YEP_RESTRICT, Yep32s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV32sS32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xRefArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV32sS32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Multiply_IV32sS32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Multiply_IV32sS32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV32sS32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV32sS32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV64sS64s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s *YEP_RESTRICT, Yep64s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV64sS64s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xRefArray[1088 + (64 / sizeof(Yep64s))];
	Yep64s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV64sS64s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Multiply_IV64sS64s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Multiply_IV64sS64s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV64sS64s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV64sS64s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV32fS32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f *YEP_RESTRICT, Yep32f, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV32fS32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xRefArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f y;

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV32fS32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV32fS32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV32fS32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV32fS32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV32fS32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Multiply_IV64fS64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f *YEP_RESTRICT, Yep64f, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Multiply_IV64fS64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xRefArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f y;

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Multiply_IV64fS64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV64fS64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Multiply_IV64fS64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Multiply_IV64fS64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Multiply_IV64fS64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

int main(int argc, char** argv) {
	YepBoolean testMultiply_V8sV8s_V8s = YepBooleanFalse;
	YepBoolean testMultiply_V8sV8s_V16s = YepBooleanFalse;
	YepBoolean testMultiply_V8uV8u_V16u = YepBooleanFalse;
	YepBoolean testMultiply_V16sV16s_V16s = YepBooleanFalse;
	YepBoolean testMultiply_V16sV16s_V32s = YepBooleanFalse;
	YepBoolean testMultiply_V16uV16u_V32u = YepBooleanFalse;
	YepBoolean testMultiply_V32sV32s_V32s = YepBooleanFalse;
	YepBoolean testMultiply_V32sV32s_V64s = YepBooleanFalse;
	YepBoolean testMultiply_V32uV32u_V64u = YepBooleanFalse;
	YepBoolean testMultiply_V64sV64s_V64s = YepBooleanFalse;
	YepBoolean testMultiply_V32fV32f_V32f = YepBooleanFalse;
	YepBoolean testMultiply_V64fV64f_V64f = YepBooleanFalse;
	YepBoolean testMultiply_V8sS8s_V8s = YepBooleanFalse;
	YepBoolean testMultiply_V8sS8s_V16s = YepBooleanFalse;
	YepBoolean testMultiply_V8uS8u_V16u = YepBooleanFalse;
	YepBoolean testMultiply_V16sS16s_V16s = YepBooleanFalse;
	YepBoolean testMultiply_V16sS16s_V32s = YepBooleanFalse;
	YepBoolean testMultiply_V16uS16u_V32u = YepBooleanFalse;
	YepBoolean testMultiply_V32sS32s_V32s = YepBooleanFalse;
	YepBoolean testMultiply_V32sS32s_V64s = YepBooleanFalse;
	YepBoolean testMultiply_V32uS32u_V64u = YepBooleanFalse;
	YepBoolean testMultiply_V64sS64s_V64s = YepBooleanFalse;
	YepBoolean testMultiply_V32fS32f_V32f = YepBooleanFalse;
	YepBoolean testMultiply_V64fS64f_V64f = YepBooleanFalse;
	YepBoolean testMultiply_IV8sV8s_IV8s = YepBooleanFalse;
	YepBoolean testMultiply_IV16sV16s_IV16s = YepBooleanFalse;
	YepBoolean testMultiply_IV32sV32s_IV32s = YepBooleanFalse;
	YepBoolean testMultiply_IV64sV64s_IV64s = YepBooleanFalse;
	YepBoolean testMultiply_IV32fV32f_IV32f = YepBooleanFalse;
	YepBoolean testMultiply_IV64fV64f_IV64f = YepBooleanFalse;
	YepBoolean testMultiply_IV8sS8s_IV8s = YepBooleanFalse;
	YepBoolean testMultiply_IV16sS16s_IV16s = YepBooleanFalse;
	YepBoolean testMultiply_IV32sS32s_IV32s = YepBooleanFalse;
	YepBoolean testMultiply_IV64sS64s_IV64s = YepBooleanFalse;
	YepBoolean testMultiply_IV32fS32f_IV32f = YepBooleanFalse;
	YepBoolean testMultiply_IV64fS64f_IV64f = YepBooleanFalse;
	if (argc == 1) {
		/* No tests specified: run all tests*/
		testMultiply_V8sV8s_V8s = YepBooleanTrue;
		testMultiply_V8sV8s_V16s = YepBooleanTrue;
		testMultiply_V8uV8u_V16u = YepBooleanTrue;
		testMultiply_V16sV16s_V16s = YepBooleanTrue;
		testMultiply_V16sV16s_V32s = YepBooleanTrue;
		testMultiply_V16uV16u_V32u = YepBooleanTrue;
		testMultiply_V32sV32s_V32s = YepBooleanTrue;
		testMultiply_V32sV32s_V64s = YepBooleanTrue;
		testMultiply_V32uV32u_V64u = YepBooleanTrue;
		testMultiply_V64sV64s_V64s = YepBooleanTrue;
		testMultiply_V32fV32f_V32f = YepBooleanTrue;
		testMultiply_V64fV64f_V64f = YepBooleanTrue;
		testMultiply_V8sS8s_V8s = YepBooleanTrue;
		testMultiply_V8sS8s_V16s = YepBooleanTrue;
		testMultiply_V8uS8u_V16u = YepBooleanTrue;
		testMultiply_V16sS16s_V16s = YepBooleanTrue;
		testMultiply_V16sS16s_V32s = YepBooleanTrue;
		testMultiply_V16uS16u_V32u = YepBooleanTrue;
		testMultiply_V32sS32s_V32s = YepBooleanTrue;
		testMultiply_V32sS32s_V64s = YepBooleanTrue;
		testMultiply_V32uS32u_V64u = YepBooleanTrue;
		testMultiply_V64sS64s_V64s = YepBooleanTrue;
		testMultiply_V32fS32f_V32f = YepBooleanTrue;
		testMultiply_V64fS64f_V64f = YepBooleanTrue;
		testMultiply_IV8sV8s_IV8s = YepBooleanTrue;
		testMultiply_IV16sV16s_IV16s = YepBooleanTrue;
		testMultiply_IV32sV32s_IV32s = YepBooleanTrue;
		testMultiply_IV64sV64s_IV64s = YepBooleanTrue;
		testMultiply_IV32fV32f_IV32f = YepBooleanTrue;
		testMultiply_IV64fV64f_IV64f = YepBooleanTrue;
		testMultiply_IV8sS8s_IV8s = YepBooleanTrue;
		testMultiply_IV16sS16s_IV16s = YepBooleanTrue;
		testMultiply_IV32sS32s_IV32s = YepBooleanTrue;
		testMultiply_IV64sS64s_IV64s = YepBooleanTrue;
		testMultiply_IV32fS32f_IV32f = YepBooleanTrue;
		testMultiply_IV64fS64f_IV64f = YepBooleanTrue;
	} else {
		/* Some tests specified: run only specified tests*/
		for (int i = 1; i < argc; i++) {
			if (strcmp(argv[i], "V8sV8s_V8s") == 0) {
				testMultiply_V8sV8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sV8s_V16s") == 0) {
				testMultiply_V8sV8s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8uV8u_V16u") == 0) {
				testMultiply_V8uV8u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sV16s_V16s") == 0) {
				testMultiply_V16sV16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sV16s_V32s") == 0) {
				testMultiply_V16sV16s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16uV16u_V32u") == 0) {
				testMultiply_V16uV16u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sV32s_V32s") == 0) {
				testMultiply_V32sV32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sV32s_V64s") == 0) {
				testMultiply_V32sV32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32uV32u_V64u") == 0) {
				testMultiply_V32uV32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sV64s_V64s") == 0) {
				testMultiply_V64sV64s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fV32f_V32f") == 0) {
				testMultiply_V32fV32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fV64f_V64f") == 0) {
				testMultiply_V64fV64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sS8s_V8s") == 0) {
				testMultiply_V8sS8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sS8s_V16s") == 0) {
				testMultiply_V8sS8s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8uS8u_V16u") == 0) {
				testMultiply_V8uS8u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sS16s_V16s") == 0) {
				testMultiply_V16sS16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sS16s_V32s") == 0) {
				testMultiply_V16sS16s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16uS16u_V32u") == 0) {
				testMultiply_V16uS16u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sS32s_V32s") == 0) {
				testMultiply_V32sS32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sS32s_V64s") == 0) {
				testMultiply_V32sS32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32uS32u_V64u") == 0) {
				testMultiply_V32uS32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sS64s_V64s") == 0) {
				testMultiply_V64sS64s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fS32f_V32f") == 0) {
				testMultiply_V32fS32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fS64f_V64f") == 0) {
				testMultiply_V64fS64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8sV8s_IV8s") == 0) {
				testMultiply_IV8sV8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16sV16s_IV16s") == 0) {
				testMultiply_IV16sV16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32sV32s_IV32s") == 0) {
				testMultiply_IV32sV32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64sV64s_IV64s") == 0) {
				testMultiply_IV64sV64s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32fV32f_IV32f") == 0) {
				testMultiply_IV32fV32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64fV64f_IV64f") == 0) {
				testMultiply_IV64fV64f_IV64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8sS8s_IV8s") == 0) {
				testMultiply_IV8sS8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16sS16s_IV16s") == 0) {
				testMultiply_IV16sS16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32sS32s_IV32s") == 0) {
				testMultiply_IV32sS32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64sS64s_IV64s") == 0) {
				testMultiply_IV64sS64s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32fS32f_IV32f") == 0) {
				testMultiply_IV32fS32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64fS64f_IV64f") == 0) {
				testMultiply_IV64fS64f_IV64f = YepBooleanTrue;
			} else {
				fprintf(stderr, "Unknown function name \"%s\"", argv[i]);
				return 1;
			}
		}
	}
	YepStatus status = _yepLibrary_InitCpuInfo();
	assert(status == YepStatusOk);

	Yep64u supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures;
	status = yepLibrary_GetCpuIsaFeatures(&supportedIsaFeatures);
	assert(status == YepStatusOk);
	status = yepLibrary_GetCpuSimdFeatures(&supportedSimdFeatures);
	assert(status == YepStatusOk);
	status = yepLibrary_GetCpuSystemFeatures(&supportedSystemFeatures);
	assert(status == YepStatusOk);

	Yep32s failedTests = 0;
	if YEP_LIKELY(testMultiply_V8sV8s_V8s)
		failedTests += Test_Multiply_V8sV8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V8sV8s_V16s)
		failedTests += Test_Multiply_V8sV8s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V8uV8u_V16u)
		failedTests += Test_Multiply_V8uV8u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V16sV16s_V16s)
		failedTests += Test_Multiply_V16sV16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V16sV16s_V32s)
		failedTests += Test_Multiply_V16sV16s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V16uV16u_V32u)
		failedTests += Test_Multiply_V16uV16u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V32sV32s_V32s)
		failedTests += Test_Multiply_V32sV32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V32sV32s_V64s)
		failedTests += Test_Multiply_V32sV32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V32uV32u_V64u)
		failedTests += Test_Multiply_V32uV32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V64sV64s_V64s)
		failedTests += Test_Multiply_V64sV64s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V32fV32f_V32f)
		failedTests += Test_Multiply_V32fV32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V64fV64f_V64f)
		failedTests += Test_Multiply_V64fV64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V8sS8s_V8s)
		failedTests += Test_Multiply_V8sS8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V8sS8s_V16s)
		failedTests += Test_Multiply_V8sS8s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V8uS8u_V16u)
		failedTests += Test_Multiply_V8uS8u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V16sS16s_V16s)
		failedTests += Test_Multiply_V16sS16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V16sS16s_V32s)
		failedTests += Test_Multiply_V16sS16s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V16uS16u_V32u)
		failedTests += Test_Multiply_V16uS16u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V32sS32s_V32s)
		failedTests += Test_Multiply_V32sS32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V32sS32s_V64s)
		failedTests += Test_Multiply_V32sS32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V32uS32u_V64u)
		failedTests += Test_Multiply_V32uS32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V64sS64s_V64s)
		failedTests += Test_Multiply_V64sS64s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V32fS32f_V32f)
		failedTests += Test_Multiply_V32fS32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_V64fS64f_V64f)
		failedTests += Test_Multiply_V64fS64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV8sV8s_IV8s)
		failedTests += Test_Multiply_IV8sV8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV16sV16s_IV16s)
		failedTests += Test_Multiply_IV16sV16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV32sV32s_IV32s)
		failedTests += Test_Multiply_IV32sV32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV64sV64s_IV64s)
		failedTests += Test_Multiply_IV64sV64s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV32fV32f_IV32f)
		failedTests += Test_Multiply_IV32fV32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV64fV64f_IV64f)
		failedTests += Test_Multiply_IV64fV64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV8sS8s_IV8s)
		failedTests += Test_Multiply_IV8sS8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV16sS16s_IV16s)
		failedTests += Test_Multiply_IV16sS16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV32sS32s_IV32s)
		failedTests += Test_Multiply_IV32sS32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV64sS64s_IV64s)
		failedTests += Test_Multiply_IV64sS64s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV32fS32f_IV32f)
		failedTests += Test_Multiply_IV32fS32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMultiply_IV64fS64f_IV64f)
		failedTests += Test_Multiply_IV64fS64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	return failedTests;
}
