/*
 *                       Yeppp! library implementation
 *                   This file is auto-generated by Peach-Py,
 *        Portable Efficient Assembly Code-generator in Higher-level Python,
 *                  part of the Yeppp! library infrastructure
 * This file is part of Yeppp! library and licensed under the New BSD license.
 * See LICENSE.txt for the full text of the license.
 */

#include <yepPredefines.h>
#include <yepPrivate.h>
#include <yepLibrary.h>
#include <library/functions.h>
#include <yepRandom.h>
#include <core/functions.h>
#include <yepBuiltin.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#ifdef YEP_WINDOWS_OS
	#include <windows.h>
	#define YEP_ESCAPE_NORMAL_COLOR ""
	#define YEP_ESCAPE_RED_COLOR ""
	#define YEP_ESCAPE_GREEN_COLOR ""
	#define YEP_ESCAPE_YELLOW_COLOR ""
#else
	#define YEP_ESCAPE_NORMAL_COLOR "\x1B[0m"
	#define YEP_ESCAPE_RED_COLOR "\x1B[31m"
	#define YEP_ESCAPE_GREEN_COLOR "\x1B[32m"
	#define YEP_ESCAPE_YELLOW_COLOR "\x1B[33m"
#endif

static const char* getMicroarchitectureName(YepCpuMicroarchitecture microarchitecture) {
	const YepSize bufferSize = 1024;
	static char buffer[bufferSize];
	YepSize bufferLength = bufferSize - 1;
	YepStatus status = yepLibrary_GetString(YepEnumerationCpuMicroarchitecture, microarchitecture, YepStringTypeDescription, buffer, &bufferLength);
	assert(status == YepStatusOk);
	buffer[bufferLength] = '\0';
	return buffer;
}

static void reportFailedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY);
		printf("FAILED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sFAILED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_RED_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static void reportFailedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture, float ulpError) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY);
		printf("FAILED");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
		printf(" (%f ULP)\n", ulpError);
	#else
		printf("%s (%s): %sFAILED%s (%f ULP)\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_RED_COLOR, YEP_ESCAPE_NORMAL_COLOR, ulpError);
	#endif
}

static void reportPassedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		printf("PASSED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sPASSED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_GREEN_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static void reportSkippedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		printf("SKIPPED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sSKIPPED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_YELLOW_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static Yep32s Test_Subtract_V8sV8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V8sV8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s diffArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s diffInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s diffRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V8sV8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep8s); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V8sV8s_V8s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V8sV8s_V8s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V8sV8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V8sV8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V8sV8s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V8sV8s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep16s diffArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V8sV8s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16s); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V8sV8s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V8sV8s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V8sV8s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V8sV8s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V8uV8u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, const Yep8u *YEP_RESTRICT, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V8uV8u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u yArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep16u diffArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u diffInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u diffRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V8uV8u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8u); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16u); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V8uV8u_V16u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V8uV8u_V16u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V8uV8u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V8uV8u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V16sV16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V16sV16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V16sV16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16s); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V16sV16s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V16sV16s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V16sV16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V16sV16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V16sV16s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V16sV16s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep32s diffArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V16sV16s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32s); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V16sV16s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V16sV16s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V16sV16s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V16sV16s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V16uV16u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, const Yep16u *YEP_RESTRICT, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V16uV16u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u yArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep32u diffArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u diffInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u diffRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V16uV16u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16u); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32u); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V16uV16u_V32u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V16uV16u_V32u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V16uV16u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V16uV16u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32sV32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32sV32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32sV32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32s); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32sV32s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32sV32s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32sV32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32sV32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32sV32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32sV32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep64s diffArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32sV32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64s); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32sV32s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32sV32s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32sV32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32sV32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32uV32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32uV32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep64u diffArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u diffInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u diffRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32uV32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64u); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32uV32u_V64u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32uV32u_V64u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32uV32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32uV32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V64sV64s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, const Yep64s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V64sV64s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V64sV64s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64s); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64s); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V64sV64s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V64sV64s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V64sV64s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V64sV64s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32fV32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, const Yep32f *YEP_RESTRICT, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32fV32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f diffArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f diffInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f diffRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32fV32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32f); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
								const Yep32f ulpError = yepBuiltin_Abs_32f_32f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_32f_32f(diffRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Subtract_V32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
								const Yep32f ulpError = yepBuiltin_Abs_32f_32f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_32f_32f(diffRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Subtract_V32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32fV32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32fV32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V64fV64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, const Yep64f *YEP_RESTRICT, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V64fV64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f diffArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f diffInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f diffRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V64fV64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64f); diffOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
								const Yep64f ulpError = yepBuiltin_Abs_64f_64f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_64f_64f(diffRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Subtract_V64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &diffRefArray[diffOffset], length);
							assert(status == YepStatusOk);

							memcpy(diffArray, diffInitArray, sizeof(diffArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &diffArray[diffOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
								const Yep64f ulpError = yepBuiltin_Abs_64f_64f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_64f_64f(diffRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Subtract_V64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V64fV64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V64fV64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V8sS8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V8sS8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;
	YEP_ALIGN(64) Yep8s diffArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s diffInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s diffRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V8sS8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep8s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V8sS8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V8sS8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V8sS8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V8sS8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V8sS8s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V8sS8s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;
	YEP_ALIGN(64) Yep16s diffArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V8sS8s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V8sS8s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V8sS8s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V8sS8s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V8sS8s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V8uS8u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, Yep8u, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V8uS8u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	Yep8u y;
	YEP_ALIGN(64) Yep16u diffArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u diffInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u diffRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V8uS8u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16u); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V8uS8u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V8uS8u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V8uS8u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V8uS8u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V16sS16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V16sS16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;
	YEP_ALIGN(64) Yep16s diffArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V16sS16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V16sS16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V16sS16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V16sS16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V16sS16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V16sS16s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V16sS16s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;
	YEP_ALIGN(64) Yep32s diffArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V16sS16s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V16sS16s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V16sS16s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V16sS16s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V16sS16s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V16uS16u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, Yep16u, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V16uS16u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	Yep16u y;
	YEP_ALIGN(64) Yep32u diffArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u diffInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u diffRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V16uS16u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32u); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V16uS16u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V16uS16u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V16uS16u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V16uS16u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32sS32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32sS32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;
	YEP_ALIGN(64) Yep32s diffArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32sS32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V32sS32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V32sS32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32sS32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32sS32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32sS32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32sS32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;
	YEP_ALIGN(64) Yep64s diffArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32sS32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V32sS32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V32sS32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32sS32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32sS32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32uS32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, Yep32u, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32uS32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	Yep32u y;
	YEP_ALIGN(64) Yep64u diffArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u diffInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u diffRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32uS32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64u); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V32uS32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V32uS32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32uS32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32uS32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V64sS64s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, Yep64s, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V64sS64s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	Yep64s y;
	YEP_ALIGN(64) Yep64s diffArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V64sS64s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V64sS64s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V64sS64s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V64sS64s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V64sS64s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32fS32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, Yep32f, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32fS32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f y;
	YEP_ALIGN(64) Yep32f diffArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f diffInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f diffRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32fS32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32f); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_32f_32f(diffRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32fS32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_32f_32f(diffRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32fS32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32fS32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32fS32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V64fS64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, Yep64f, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V64fS64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f y;
	YEP_ALIGN(64) Yep64f diffArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f diffInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f diffRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V64fS64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64f); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_64f_64f(diffRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V64fS64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(&xArray[xOffset], y, &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_64f_64f(diffRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V64fS64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V64fS64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V64fS64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S8sV8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s, const Yep8s *YEP_RESTRICT, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S8sV8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep8s x;
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s diffArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s diffInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s diffRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S8sV8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep8s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S8sV8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S8sV8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S8sV8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S8sV8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S8sV8s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s, const Yep8s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S8sV8s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep8s x;
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep16s diffArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S8sV8s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S8sV8s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S8sV8s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S8sV8s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S8sV8s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S8uV8u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8u, const Yep8u *YEP_RESTRICT, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S8uV8u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep8u x;
	YEP_ALIGN(64) Yep8u yArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep16u diffArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u diffInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u diffRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S8uV8u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8u); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16u); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S8uV8u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S8uV8u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S8uV8u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S8uV8u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S16sV16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s, const Yep16s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S16sV16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep16s x;
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s diffRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S16sV16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep16s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S16sV16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S16sV16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S16sV16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S16sV16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S16sV16s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s, const Yep16s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S16sV16s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep16s x;
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep32s diffArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S16sV16s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S16sV16s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S16sV16s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S16sV16s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S16sV16s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S16uV16u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16u, const Yep16u *YEP_RESTRICT, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S16uV16u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep16u x;
	YEP_ALIGN(64) Yep16u yArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep32u diffArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u diffInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u diffRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S16uV16u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16u); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32u); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S16uV16u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S16uV16u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S16uV16u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S16uV16u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S32sV32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s, const Yep32s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S32sV32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep32s x;
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s diffRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S32sV32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S32sV32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S32sV32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S32sV32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S32sV32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S32sV32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s, const Yep32s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S32sV32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep32s x;
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep64s diffArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S32sV32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S32sV32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S32sV32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S32sV32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S32sV32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S32uV32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32u, const Yep32u *YEP_RESTRICT, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S32uV32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep32u x;
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep64u diffArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u diffInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u diffRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S32uV32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64u); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S32uV32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S32uV32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S32uV32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S32uV32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S64sV64s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s, const Yep64s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S64sV64s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep64s x;
	YEP_ALIGN(64) Yep64s yArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s diffRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S64sV64s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64s); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64s); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S64sV64s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(diffArray, diffRefArray, sizeof(diffArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S64sV64s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S64sV64s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S64sV64s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S32fV32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f, const Yep32f *YEP_RESTRICT, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S32fV32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep32f x;
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f diffArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f diffInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f diffRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S32fV32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep32f); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_32f_32f(diffRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_S32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_32f_32f(diffRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_S32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S32fV32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S32fV32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S64fV64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f, const Yep64f *YEP_RESTRICT, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S64fV64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep64f x;
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f diffArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f diffInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f diffRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, diffInitArray, YEP_COUNT_OF(diffInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S64fV64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
				for (YepSize diffOffset = 0; diffOffset < 64 / sizeof(Yep64f); diffOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_64f_64f(diffRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_S64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(diffRefArray, diffInitArray, sizeof(diffRefArray));
						status = defaultImplementation(x, &yArray[yOffset], &diffRefArray[diffOffset], length);
						assert(status == YepStatusOk);

						memcpy(diffArray, diffInitArray, sizeof(diffArray));
						status = descriptor->function(x, &yArray[yOffset], &diffArray[diffOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(diffArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(diffRefArray[i] - diffArray[i]) / yepBuiltin_Ulp_64f_64f(diffRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_S64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S64fV64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S64fV64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV8sV8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV8sV8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xRefArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV8sV8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV8sV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV8sV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV8sV8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV8sV8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV16sV16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV16sV16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xRefArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV16sV16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV16sV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV16sV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV16sV16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV16sV16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV32sV32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV32sV32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xRefArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV32sV32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV32sV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV32sV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV32sV32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV32sV32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV64sV64s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s *YEP_RESTRICT, const Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV64sV64s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xRefArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV64sV64s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV64sV64s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV64sV64s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV64sV64s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV64sV64s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV32fV32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f *YEP_RESTRICT, const Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV32fV32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xRefArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV32fV32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_IV32fV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_IV32fV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV32fV32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV32fV32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV64fV64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f *YEP_RESTRICT, const Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV64fV64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xRefArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV64fV64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_IV64fV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_IV64fV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV64fV64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV64fV64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V8sIV8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V8sIV8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V8sIV8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V8sIV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V8sIV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V8sIV8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V8sIV8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V16sIV16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V16sIV16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V16sIV16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V16sIV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V16sIV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V16sIV16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V16sIV16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32sIV32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32sIV32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32sIV32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V32sIV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V32sIV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32sIV32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32sIV32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V64sIV64s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V64sIV64s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V64sIV64s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V64sIV64s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_V64sIV64s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V64sIV64s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V64sIV64s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V32fIV32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V32fIV32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V32fIV32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(yArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(yRefArray[i] - yArray[i]) / yepBuiltin_Ulp_32f_32f(yRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32fIV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(yArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(yRefArray[i] - yArray[i]) / yepBuiltin_Ulp_32f_32f(yRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V32fIV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V32fIV32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V32fIV32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_V64fIV64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_V64fIV64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_V64fIV64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(yArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(yRefArray[i] - yArray[i]) / yepBuiltin_Ulp_64f_64f(yRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V64fIV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(yRefArray, yInitArray, sizeof(yRefArray));
						status = defaultImplementation(&xArray[xOffset], &yRefArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(yArray, yInitArray, sizeof(yArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(yArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(yRefArray[i] - yArray[i]) / yepBuiltin_Ulp_64f_64f(yRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Subtract_V64fIV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_V64fIV64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_V64fIV64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV8sS8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s *YEP_RESTRICT, Yep8s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV8sS8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xRefArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV8sS8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_IV8sS8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_IV8sS8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV8sS8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV8sS8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV16sS16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s *YEP_RESTRICT, Yep16s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV16sS16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xRefArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV16sS16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_IV16sS16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_IV16sS16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV16sS16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV16sS16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV32sS32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s *YEP_RESTRICT, Yep32s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV32sS32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xRefArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV32sS32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_IV32sS32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_IV32sS32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV32sS32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV32sS32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV64sS64s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s *YEP_RESTRICT, Yep64s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV64sS64s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xRefArray[1088 + (64 / sizeof(Yep64s))];
	Yep64s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV64sS64s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_IV64sS64s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_IV64sS64s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV64sS64s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV64sS64s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV32fS32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f *YEP_RESTRICT, Yep32f, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV32fS32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xRefArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f y;

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV32fS32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV32fS32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV32fS32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV32fS32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV32fS32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_IV64fS64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f *YEP_RESTRICT, Yep64f, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_IV64fS64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xRefArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f y;

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_IV64fS64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV64fS64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_IV64fS64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_IV64fS64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_IV64fS64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S8sIV8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S8sIV8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep8s x;
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S8sIV8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_S8sIV8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_S8sIV8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S8sIV8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S8sIV8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S16sIV16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S16sIV16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep16s x;
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S16sIV16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_S16sIV16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_S16sIV16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S16sIV16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S16sIV16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S32sIV32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S32sIV32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep32s x;
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S32sIV32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_S32sIV32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_S32sIV32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S32sIV32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S32sIV32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S64sIV64s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S64sIV64s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep64s x;
	YEP_ALIGN(64) Yep64s yArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s yRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S64sIV64s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64s); yOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_S64sIV64s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					if (memcmp(yArray, yRefArray, sizeof(yArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Subtract_S64sIV64s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S64sIV64s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S64sIV64s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S32fIV32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S32fIV32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep32f x;
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S32fIV32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(yArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(yRefArray[i] - yArray[i]) / yepBuiltin_Ulp_32f_32f(yRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S32fIV32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(yArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(yRefArray[i] - yArray[i]) / yepBuiltin_Ulp_32f_32f(yRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S32fIV32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S32fIV32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S32fIV32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Subtract_S64fIV64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Subtract_S64fIV64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	Yep64f x;
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &x, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yInitArray, YEP_COUNT_OF(yInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Subtract_S64fIV64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(yArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(yRefArray[i] - yArray[i]) / yepBuiltin_Ulp_64f_64f(yRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S64fIV64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(yRefArray, yInitArray, sizeof(yRefArray));
					status = defaultImplementation(x, &yRefArray[yOffset], length);
					assert(status == YepStatusOk);

					memcpy(yArray, yInitArray, sizeof(yArray));
					status = descriptor->function(x, &yArray[yOffset], length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(yArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(yRefArray[i] - yArray[i]) / yepBuiltin_Ulp_64f_64f(yRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Subtract_S64fIV64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Subtract_S64fIV64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Subtract_S64fIV64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

int main(int argc, char** argv) {
	YepBoolean testSubtract_V8sV8s_V8s = YepBooleanFalse;
	YepBoolean testSubtract_V8sV8s_V16s = YepBooleanFalse;
	YepBoolean testSubtract_V8uV8u_V16u = YepBooleanFalse;
	YepBoolean testSubtract_V16sV16s_V16s = YepBooleanFalse;
	YepBoolean testSubtract_V16sV16s_V32s = YepBooleanFalse;
	YepBoolean testSubtract_V16uV16u_V32u = YepBooleanFalse;
	YepBoolean testSubtract_V32sV32s_V32s = YepBooleanFalse;
	YepBoolean testSubtract_V32sV32s_V64s = YepBooleanFalse;
	YepBoolean testSubtract_V32uV32u_V64u = YepBooleanFalse;
	YepBoolean testSubtract_V64sV64s_V64s = YepBooleanFalse;
	YepBoolean testSubtract_V32fV32f_V32f = YepBooleanFalse;
	YepBoolean testSubtract_V64fV64f_V64f = YepBooleanFalse;
	YepBoolean testSubtract_V8sS8s_V8s = YepBooleanFalse;
	YepBoolean testSubtract_V8sS8s_V16s = YepBooleanFalse;
	YepBoolean testSubtract_V8uS8u_V16u = YepBooleanFalse;
	YepBoolean testSubtract_V16sS16s_V16s = YepBooleanFalse;
	YepBoolean testSubtract_V16sS16s_V32s = YepBooleanFalse;
	YepBoolean testSubtract_V16uS16u_V32u = YepBooleanFalse;
	YepBoolean testSubtract_V32sS32s_V32s = YepBooleanFalse;
	YepBoolean testSubtract_V32sS32s_V64s = YepBooleanFalse;
	YepBoolean testSubtract_V32uS32u_V64u = YepBooleanFalse;
	YepBoolean testSubtract_V64sS64s_V64s = YepBooleanFalse;
	YepBoolean testSubtract_V32fS32f_V32f = YepBooleanFalse;
	YepBoolean testSubtract_V64fS64f_V64f = YepBooleanFalse;
	YepBoolean testSubtract_S8sV8s_V8s = YepBooleanFalse;
	YepBoolean testSubtract_S8sV8s_V16s = YepBooleanFalse;
	YepBoolean testSubtract_S8uV8u_V16u = YepBooleanFalse;
	YepBoolean testSubtract_S16sV16s_V16s = YepBooleanFalse;
	YepBoolean testSubtract_S16sV16s_V32s = YepBooleanFalse;
	YepBoolean testSubtract_S16uV16u_V32u = YepBooleanFalse;
	YepBoolean testSubtract_S32sV32s_V32s = YepBooleanFalse;
	YepBoolean testSubtract_S32sV32s_V64s = YepBooleanFalse;
	YepBoolean testSubtract_S32uV32u_V64u = YepBooleanFalse;
	YepBoolean testSubtract_S64sV64s_V64s = YepBooleanFalse;
	YepBoolean testSubtract_S32fV32f_V32f = YepBooleanFalse;
	YepBoolean testSubtract_S64fV64f_V64f = YepBooleanFalse;
	YepBoolean testSubtract_IV8sV8s_IV8s = YepBooleanFalse;
	YepBoolean testSubtract_IV16sV16s_IV16s = YepBooleanFalse;
	YepBoolean testSubtract_IV32sV32s_IV32s = YepBooleanFalse;
	YepBoolean testSubtract_IV64sV64s_IV64s = YepBooleanFalse;
	YepBoolean testSubtract_IV32fV32f_IV32f = YepBooleanFalse;
	YepBoolean testSubtract_IV64fV64f_IV64f = YepBooleanFalse;
	YepBoolean testSubtract_V8sIV8s_IV8s = YepBooleanFalse;
	YepBoolean testSubtract_V16sIV16s_IV16s = YepBooleanFalse;
	YepBoolean testSubtract_V32sIV32s_IV32s = YepBooleanFalse;
	YepBoolean testSubtract_V64sIV64s_IV64s = YepBooleanFalse;
	YepBoolean testSubtract_V32fIV32f_IV32f = YepBooleanFalse;
	YepBoolean testSubtract_V64fIV64f_IV64f = YepBooleanFalse;
	YepBoolean testSubtract_IV8sS8s_IV8s = YepBooleanFalse;
	YepBoolean testSubtract_IV16sS16s_IV16s = YepBooleanFalse;
	YepBoolean testSubtract_IV32sS32s_IV32s = YepBooleanFalse;
	YepBoolean testSubtract_IV64sS64s_IV64s = YepBooleanFalse;
	YepBoolean testSubtract_IV32fS32f_IV32f = YepBooleanFalse;
	YepBoolean testSubtract_IV64fS64f_IV64f = YepBooleanFalse;
	YepBoolean testSubtract_S8sIV8s_IV8s = YepBooleanFalse;
	YepBoolean testSubtract_S16sIV16s_IV16s = YepBooleanFalse;
	YepBoolean testSubtract_S32sIV32s_IV32s = YepBooleanFalse;
	YepBoolean testSubtract_S64sIV64s_IV64s = YepBooleanFalse;
	YepBoolean testSubtract_S32fIV32f_IV32f = YepBooleanFalse;
	YepBoolean testSubtract_S64fIV64f_IV64f = YepBooleanFalse;
	if (argc == 1) {
		/* No tests specified: run all tests*/
		testSubtract_V8sV8s_V8s = YepBooleanTrue;
		testSubtract_V8sV8s_V16s = YepBooleanTrue;
		testSubtract_V8uV8u_V16u = YepBooleanTrue;
		testSubtract_V16sV16s_V16s = YepBooleanTrue;
		testSubtract_V16sV16s_V32s = YepBooleanTrue;
		testSubtract_V16uV16u_V32u = YepBooleanTrue;
		testSubtract_V32sV32s_V32s = YepBooleanTrue;
		testSubtract_V32sV32s_V64s = YepBooleanTrue;
		testSubtract_V32uV32u_V64u = YepBooleanTrue;
		testSubtract_V64sV64s_V64s = YepBooleanTrue;
		testSubtract_V32fV32f_V32f = YepBooleanTrue;
		testSubtract_V64fV64f_V64f = YepBooleanTrue;
		testSubtract_V8sS8s_V8s = YepBooleanTrue;
		testSubtract_V8sS8s_V16s = YepBooleanTrue;
		testSubtract_V8uS8u_V16u = YepBooleanTrue;
		testSubtract_V16sS16s_V16s = YepBooleanTrue;
		testSubtract_V16sS16s_V32s = YepBooleanTrue;
		testSubtract_V16uS16u_V32u = YepBooleanTrue;
		testSubtract_V32sS32s_V32s = YepBooleanTrue;
		testSubtract_V32sS32s_V64s = YepBooleanTrue;
		testSubtract_V32uS32u_V64u = YepBooleanTrue;
		testSubtract_V64sS64s_V64s = YepBooleanTrue;
		testSubtract_V32fS32f_V32f = YepBooleanTrue;
		testSubtract_V64fS64f_V64f = YepBooleanTrue;
		testSubtract_S8sV8s_V8s = YepBooleanTrue;
		testSubtract_S8sV8s_V16s = YepBooleanTrue;
		testSubtract_S8uV8u_V16u = YepBooleanTrue;
		testSubtract_S16sV16s_V16s = YepBooleanTrue;
		testSubtract_S16sV16s_V32s = YepBooleanTrue;
		testSubtract_S16uV16u_V32u = YepBooleanTrue;
		testSubtract_S32sV32s_V32s = YepBooleanTrue;
		testSubtract_S32sV32s_V64s = YepBooleanTrue;
		testSubtract_S32uV32u_V64u = YepBooleanTrue;
		testSubtract_S64sV64s_V64s = YepBooleanTrue;
		testSubtract_S32fV32f_V32f = YepBooleanTrue;
		testSubtract_S64fV64f_V64f = YepBooleanTrue;
		testSubtract_IV8sV8s_IV8s = YepBooleanTrue;
		testSubtract_IV16sV16s_IV16s = YepBooleanTrue;
		testSubtract_IV32sV32s_IV32s = YepBooleanTrue;
		testSubtract_IV64sV64s_IV64s = YepBooleanTrue;
		testSubtract_IV32fV32f_IV32f = YepBooleanTrue;
		testSubtract_IV64fV64f_IV64f = YepBooleanTrue;
		testSubtract_V8sIV8s_IV8s = YepBooleanTrue;
		testSubtract_V16sIV16s_IV16s = YepBooleanTrue;
		testSubtract_V32sIV32s_IV32s = YepBooleanTrue;
		testSubtract_V64sIV64s_IV64s = YepBooleanTrue;
		testSubtract_V32fIV32f_IV32f = YepBooleanTrue;
		testSubtract_V64fIV64f_IV64f = YepBooleanTrue;
		testSubtract_IV8sS8s_IV8s = YepBooleanTrue;
		testSubtract_IV16sS16s_IV16s = YepBooleanTrue;
		testSubtract_IV32sS32s_IV32s = YepBooleanTrue;
		testSubtract_IV64sS64s_IV64s = YepBooleanTrue;
		testSubtract_IV32fS32f_IV32f = YepBooleanTrue;
		testSubtract_IV64fS64f_IV64f = YepBooleanTrue;
		testSubtract_S8sIV8s_IV8s = YepBooleanTrue;
		testSubtract_S16sIV16s_IV16s = YepBooleanTrue;
		testSubtract_S32sIV32s_IV32s = YepBooleanTrue;
		testSubtract_S64sIV64s_IV64s = YepBooleanTrue;
		testSubtract_S32fIV32f_IV32f = YepBooleanTrue;
		testSubtract_S64fIV64f_IV64f = YepBooleanTrue;
	} else {
		/* Some tests specified: run only specified tests*/
		for (int i = 1; i < argc; i++) {
			if (strcmp(argv[i], "V8sV8s_V8s") == 0) {
				testSubtract_V8sV8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sV8s_V16s") == 0) {
				testSubtract_V8sV8s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8uV8u_V16u") == 0) {
				testSubtract_V8uV8u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sV16s_V16s") == 0) {
				testSubtract_V16sV16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sV16s_V32s") == 0) {
				testSubtract_V16sV16s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16uV16u_V32u") == 0) {
				testSubtract_V16uV16u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sV32s_V32s") == 0) {
				testSubtract_V32sV32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sV32s_V64s") == 0) {
				testSubtract_V32sV32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32uV32u_V64u") == 0) {
				testSubtract_V32uV32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sV64s_V64s") == 0) {
				testSubtract_V64sV64s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fV32f_V32f") == 0) {
				testSubtract_V32fV32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fV64f_V64f") == 0) {
				testSubtract_V64fV64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sS8s_V8s") == 0) {
				testSubtract_V8sS8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sS8s_V16s") == 0) {
				testSubtract_V8sS8s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8uS8u_V16u") == 0) {
				testSubtract_V8uS8u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sS16s_V16s") == 0) {
				testSubtract_V16sS16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sS16s_V32s") == 0) {
				testSubtract_V16sS16s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16uS16u_V32u") == 0) {
				testSubtract_V16uS16u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sS32s_V32s") == 0) {
				testSubtract_V32sS32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sS32s_V64s") == 0) {
				testSubtract_V32sS32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32uS32u_V64u") == 0) {
				testSubtract_V32uS32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sS64s_V64s") == 0) {
				testSubtract_V64sS64s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fS32f_V32f") == 0) {
				testSubtract_V32fS32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fS64f_V64f") == 0) {
				testSubtract_V64fS64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "S8sV8s_V8s") == 0) {
				testSubtract_S8sV8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S8sV8s_V16s") == 0) {
				testSubtract_S8sV8s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S8uV8u_V16u") == 0) {
				testSubtract_S8uV8u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "S16sV16s_V16s") == 0) {
				testSubtract_S16sV16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S16sV16s_V32s") == 0) {
				testSubtract_S16sV16s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S16uV16u_V32u") == 0) {
				testSubtract_S16uV16u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "S32sV32s_V32s") == 0) {
				testSubtract_S32sV32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S32sV32s_V64s") == 0) {
				testSubtract_S32sV32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S32uV32u_V64u") == 0) {
				testSubtract_S32uV32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "S64sV64s_V64s") == 0) {
				testSubtract_S64sV64s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S32fV32f_V32f") == 0) {
				testSubtract_S32fV32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "S64fV64f_V64f") == 0) {
				testSubtract_S64fV64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8sV8s_IV8s") == 0) {
				testSubtract_IV8sV8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16sV16s_IV16s") == 0) {
				testSubtract_IV16sV16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32sV32s_IV32s") == 0) {
				testSubtract_IV32sV32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64sV64s_IV64s") == 0) {
				testSubtract_IV64sV64s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32fV32f_IV32f") == 0) {
				testSubtract_IV32fV32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64fV64f_IV64f") == 0) {
				testSubtract_IV64fV64f_IV64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sIV8s_IV8s") == 0) {
				testSubtract_V8sIV8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sIV16s_IV16s") == 0) {
				testSubtract_V16sIV16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sIV32s_IV32s") == 0) {
				testSubtract_V32sIV32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sIV64s_IV64s") == 0) {
				testSubtract_V64sIV64s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fIV32f_IV32f") == 0) {
				testSubtract_V32fIV32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fIV64f_IV64f") == 0) {
				testSubtract_V64fIV64f_IV64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8sS8s_IV8s") == 0) {
				testSubtract_IV8sS8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16sS16s_IV16s") == 0) {
				testSubtract_IV16sS16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32sS32s_IV32s") == 0) {
				testSubtract_IV32sS32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64sS64s_IV64s") == 0) {
				testSubtract_IV64sS64s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32fS32f_IV32f") == 0) {
				testSubtract_IV32fS32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64fS64f_IV64f") == 0) {
				testSubtract_IV64fS64f_IV64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "S8sIV8s_IV8s") == 0) {
				testSubtract_S8sIV8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S16sIV16s_IV16s") == 0) {
				testSubtract_S16sIV16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S32sIV32s_IV32s") == 0) {
				testSubtract_S32sIV32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S64sIV64s_IV64s") == 0) {
				testSubtract_S64sIV64s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "S32fIV32f_IV32f") == 0) {
				testSubtract_S32fIV32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "S64fIV64f_IV64f") == 0) {
				testSubtract_S64fIV64f_IV64f = YepBooleanTrue;
			} else {
				fprintf(stderr, "Unknown function name \"%s\"", argv[i]);
				return 1;
			}
		}
	}
	YepStatus status = _yepLibrary_InitCpuInfo();
	assert(status == YepStatusOk);

	Yep64u supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures;
	status = yepLibrary_GetCpuIsaFeatures(&supportedIsaFeatures);
	assert(status == YepStatusOk);
	status = yepLibrary_GetCpuSimdFeatures(&supportedSimdFeatures);
	assert(status == YepStatusOk);
	status = yepLibrary_GetCpuSystemFeatures(&supportedSystemFeatures);
	assert(status == YepStatusOk);

	Yep32s failedTests = 0;
	if YEP_LIKELY(testSubtract_V8sV8s_V8s)
		failedTests += Test_Subtract_V8sV8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V8sV8s_V16s)
		failedTests += Test_Subtract_V8sV8s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V8uV8u_V16u)
		failedTests += Test_Subtract_V8uV8u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V16sV16s_V16s)
		failedTests += Test_Subtract_V16sV16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V16sV16s_V32s)
		failedTests += Test_Subtract_V16sV16s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V16uV16u_V32u)
		failedTests += Test_Subtract_V16uV16u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32sV32s_V32s)
		failedTests += Test_Subtract_V32sV32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32sV32s_V64s)
		failedTests += Test_Subtract_V32sV32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32uV32u_V64u)
		failedTests += Test_Subtract_V32uV32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V64sV64s_V64s)
		failedTests += Test_Subtract_V64sV64s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32fV32f_V32f)
		failedTests += Test_Subtract_V32fV32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V64fV64f_V64f)
		failedTests += Test_Subtract_V64fV64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V8sS8s_V8s)
		failedTests += Test_Subtract_V8sS8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V8sS8s_V16s)
		failedTests += Test_Subtract_V8sS8s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V8uS8u_V16u)
		failedTests += Test_Subtract_V8uS8u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V16sS16s_V16s)
		failedTests += Test_Subtract_V16sS16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V16sS16s_V32s)
		failedTests += Test_Subtract_V16sS16s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V16uS16u_V32u)
		failedTests += Test_Subtract_V16uS16u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32sS32s_V32s)
		failedTests += Test_Subtract_V32sS32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32sS32s_V64s)
		failedTests += Test_Subtract_V32sS32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32uS32u_V64u)
		failedTests += Test_Subtract_V32uS32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V64sS64s_V64s)
		failedTests += Test_Subtract_V64sS64s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32fS32f_V32f)
		failedTests += Test_Subtract_V32fS32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V64fS64f_V64f)
		failedTests += Test_Subtract_V64fS64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S8sV8s_V8s)
		failedTests += Test_Subtract_S8sV8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S8sV8s_V16s)
		failedTests += Test_Subtract_S8sV8s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S8uV8u_V16u)
		failedTests += Test_Subtract_S8uV8u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S16sV16s_V16s)
		failedTests += Test_Subtract_S16sV16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S16sV16s_V32s)
		failedTests += Test_Subtract_S16sV16s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S16uV16u_V32u)
		failedTests += Test_Subtract_S16uV16u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S32sV32s_V32s)
		failedTests += Test_Subtract_S32sV32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S32sV32s_V64s)
		failedTests += Test_Subtract_S32sV32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S32uV32u_V64u)
		failedTests += Test_Subtract_S32uV32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S64sV64s_V64s)
		failedTests += Test_Subtract_S64sV64s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S32fV32f_V32f)
		failedTests += Test_Subtract_S32fV32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S64fV64f_V64f)
		failedTests += Test_Subtract_S64fV64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV8sV8s_IV8s)
		failedTests += Test_Subtract_IV8sV8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV16sV16s_IV16s)
		failedTests += Test_Subtract_IV16sV16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV32sV32s_IV32s)
		failedTests += Test_Subtract_IV32sV32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV64sV64s_IV64s)
		failedTests += Test_Subtract_IV64sV64s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV32fV32f_IV32f)
		failedTests += Test_Subtract_IV32fV32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV64fV64f_IV64f)
		failedTests += Test_Subtract_IV64fV64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V8sIV8s_IV8s)
		failedTests += Test_Subtract_V8sIV8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V16sIV16s_IV16s)
		failedTests += Test_Subtract_V16sIV16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32sIV32s_IV32s)
		failedTests += Test_Subtract_V32sIV32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V64sIV64s_IV64s)
		failedTests += Test_Subtract_V64sIV64s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V32fIV32f_IV32f)
		failedTests += Test_Subtract_V32fIV32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_V64fIV64f_IV64f)
		failedTests += Test_Subtract_V64fIV64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV8sS8s_IV8s)
		failedTests += Test_Subtract_IV8sS8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV16sS16s_IV16s)
		failedTests += Test_Subtract_IV16sS16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV32sS32s_IV32s)
		failedTests += Test_Subtract_IV32sS32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV64sS64s_IV64s)
		failedTests += Test_Subtract_IV64sS64s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV32fS32f_IV32f)
		failedTests += Test_Subtract_IV32fS32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_IV64fS64f_IV64f)
		failedTests += Test_Subtract_IV64fS64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S8sIV8s_IV8s)
		failedTests += Test_Subtract_S8sIV8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S16sIV16s_IV16s)
		failedTests += Test_Subtract_S16sIV16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S32sIV32s_IV32s)
		failedTests += Test_Subtract_S32sIV32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S64sIV64s_IV64s)
		failedTests += Test_Subtract_S64sIV64s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S32fIV32f_IV32f)
		failedTests += Test_Subtract_S32fIV32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testSubtract_S64fIV64f_IV64f)
		failedTests += Test_Subtract_S64fIV64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	return failedTests;
}
