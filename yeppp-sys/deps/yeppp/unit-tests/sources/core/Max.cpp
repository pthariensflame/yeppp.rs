/*
 *                       Yeppp! library implementation
 *                   This file is auto-generated by Peach-Py,
 *        Portable Efficient Assembly Code-generator in Higher-level Python,
 *                  part of the Yeppp! library infrastructure
 * This file is part of Yeppp! library and licensed under the New BSD license.
 * See LICENSE.txt for the full text of the license.
 */

#include <yepPredefines.h>
#include <yepPrivate.h>
#include <yepLibrary.h>
#include <library/functions.h>
#include <yepRandom.h>
#include <core/functions.h>
#include <yepBuiltin.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#ifdef YEP_WINDOWS_OS
	#include <windows.h>
	#define YEP_ESCAPE_NORMAL_COLOR ""
	#define YEP_ESCAPE_RED_COLOR ""
	#define YEP_ESCAPE_GREEN_COLOR ""
	#define YEP_ESCAPE_YELLOW_COLOR ""
#else
	#define YEP_ESCAPE_NORMAL_COLOR "\x1B[0m"
	#define YEP_ESCAPE_RED_COLOR "\x1B[31m"
	#define YEP_ESCAPE_GREEN_COLOR "\x1B[32m"
	#define YEP_ESCAPE_YELLOW_COLOR "\x1B[33m"
#endif

static const char* getMicroarchitectureName(YepCpuMicroarchitecture microarchitecture) {
	const YepSize bufferSize = 1024;
	static char buffer[bufferSize];
	YepSize bufferLength = bufferSize - 1;
	YepStatus status = yepLibrary_GetString(YepEnumerationCpuMicroarchitecture, microarchitecture, YepStringTypeDescription, buffer, &bufferLength);
	assert(status == YepStatusOk);
	buffer[bufferLength] = '\0';
	return buffer;
}

static void reportFailedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY);
		printf("FAILED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sFAILED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_RED_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static void reportFailedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture, float ulpError) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY);
		printf("FAILED");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
		printf(" (%f ULP)\n", ulpError);
	#else
		printf("%s (%s): %sFAILED%s (%f ULP)\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_RED_COLOR, YEP_ESCAPE_NORMAL_COLOR, ulpError);
	#endif
}

static void reportPassedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		printf("PASSED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sPASSED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_GREEN_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static void reportSkippedTest(const char* functionName, YepCpuMicroarchitecture microarchitecture) {
	#ifdef YEP_WINDOWS_OS
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
		::GetConsoleScreenBufferInfo(::GetStdHandle(STD_OUTPUT_HANDLE), &bufferInfo);
		printf("%s (%s): ", functionName, getMicroarchitectureName(microarchitecture));
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		printf("SKIPPED\n");
		fflush(stdout);
		::SetConsoleTextAttribute(::GetStdHandle(STD_OUTPUT_HANDLE), bufferInfo.wAttributes);
	#else
		printf("%s (%s): %sSKIPPED%s\n", functionName, getMicroarchitectureName(microarchitecture), YEP_ESCAPE_YELLOW_COLOR, YEP_ESCAPE_NORMAL_COLOR);
	#endif
}

static Yep32s Test_Max_V8s_S8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V8s_S8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s vArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s maximum;
	Yep8s maximumInit;
	Yep8s maximumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V8s_S8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep8s); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V8s_S8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V8s_S8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V8s_S8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V8s_S8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V8u_S8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, Yep8u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V8u_S8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u vArray[1088 + (64 / sizeof(Yep8u))];
	Yep8u maximum;
	Yep8u maximumInit;
	Yep8u maximumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V8u_S8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep8u); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V8u_S8u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V8u_S8u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V8u_S8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V8u_S8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V16s_S16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V16s_S16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s vArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s maximum;
	Yep16s maximumInit;
	Yep16s maximumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V16s_S16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep16s); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V16s_S16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V16s_S16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V16s_S16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V16s_S16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V16u_S16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V16u_S16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u vArray[1088 + (64 / sizeof(Yep16u))];
	Yep16u maximum;
	Yep16u maximumInit;
	Yep16u maximumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V16u_S16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep16u); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V16u_S16u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V16u_S16u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V16u_S16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V16u_S16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32s_S32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32s_S32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s vArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s maximum;
	Yep32s maximumInit;
	Yep32s maximumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32s_S32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep32s); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V32s_S32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V32s_S32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V32s_S32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32s_S32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32u_S32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32u_S32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u vArray[1088 + (64 / sizeof(Yep32u))];
	Yep32u maximum;
	Yep32u maximumInit;
	Yep32u maximumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32u_S32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep32u); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V32u_S32u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V32u_S32u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V32u_S32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32u_S32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64s_S64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64s_S64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s vArray[1088 + (64 / sizeof(Yep64s))];
	Yep64s maximum;
	Yep64s maximumInit;
	Yep64s maximumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64s_S64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep64s); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V64s_S64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V64s_S64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V64s_S64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64s_S64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64u_S64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64u *YEP_RESTRICT, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64u_S64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u vArray[1088 + (64 / sizeof(Yep64u))];
	Yep64u maximum;
	Yep64u maximumInit;
	Yep64u maximumRef;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64u_S64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep64u); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V64u_S64u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					if (maximum != maximumRef) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V64u_S64u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V64u_S64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64u_S64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32f_S32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32f_S32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f vArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f maximum;
	Yep32f maximumInit;
	Yep32f maximumRef;

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32f_S32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep32f); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					const Yep32f ulpError = yepBuiltin_Abs_32f_32f(maximumRef - maximum) / yepBuiltin_Ulp_32f_32f(maximumRef);
					if (ulpError > 1000.0f) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V32f_S32f", descriptor->microarchitecture, float(ulpError));
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					const Yep32f ulpError = yepBuiltin_Abs_32f_32f(maximumRef - maximum) / yepBuiltin_Ulp_32f_32f(maximumRef);
					if (ulpError > 1000.0f) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V32f_S32f", descriptor->microarchitecture, float(ulpError));
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V32f_S32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32f_S32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64f_S64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64f_S64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f vArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f maximum;
	Yep64f maximumInit;
	Yep64f maximumRef;

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, vArray, YEP_COUNT_OF(vArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &maximumInit, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64f_S64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize vOffset = 0; vOffset < 64 / sizeof(Yep64f); vOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					const Yep64f ulpError = yepBuiltin_Abs_64f_64f(maximumRef - maximum) / yepBuiltin_Ulp_64f_64f(maximumRef);
					if (ulpError > 1000.0f) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V64f_S64f", descriptor->microarchitecture, float(ulpError));
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					maximumRef = maximumInit;
					status = defaultImplementation(&vArray[vOffset], &maximumRef, length);
					assert(status == YepStatusOk);

					maximum = maximumInit;
					status = descriptor->function(&vArray[vOffset], &maximum, length);
					assert(status == YepStatusOk);

					const Yep64f ulpError = yepBuiltin_Abs_64f_64f(maximumRef - maximum) / yepBuiltin_Ulp_64f_64f(maximumRef);
					if (ulpError > 1000.0f) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_V64f_S64f", descriptor->microarchitecture, float(ulpError));
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_V64f_S64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64f_S64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V8sV8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V8sV8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s maximumArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s maximumInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s maximumRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V8sV8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep8s); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V8sV8s_V8s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V8sV8s_V8s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V8sV8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V8sV8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V8uV8u_V8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, const Yep8u *YEP_RESTRICT, Yep8u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V8uV8u_V8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u yArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u maximumArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u maximumInitArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u maximumRefArray[1088 + (64 / sizeof(Yep8u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V8uV8u_V8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8u); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep8u); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V8uV8u_V8u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V8uV8u_V8u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V8uV8u_V8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V8uV8u_V8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V16sV16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V16sV16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s maximumArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s maximumInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s maximumRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V16sV16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep16s); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V16sV16s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V16sV16s_V16s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V16sV16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V16sV16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V16uV16u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, const Yep16u *YEP_RESTRICT, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V16uV16u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u yArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u maximumArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u maximumInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u maximumRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V16uV16u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16u); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep16u); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V16uV16u_V16u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V16uV16u_V16u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V16uV16u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V16uV16u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32sV32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32sV32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s maximumArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s maximumInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s maximumRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32sV32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep32s); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V32sV32s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V32sV32s_V32s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V32sV32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32sV32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32uV32u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32uV32u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u maximumArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u maximumInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u maximumRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32uV32u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep32u); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V32uV32u_V32u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V32uV32u_V32u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V32uV32u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32uV32u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64sV32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64sV32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep64s maximumArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s maximumInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s maximumRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64sV32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep64s); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V64sV32s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V64sV32s_V64s", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V64sV32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64sV32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64uV32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64uV32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u xArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep64u maximumArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u maximumInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u maximumRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64uV32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep64u); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V64uV32u_V64u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V64uV32u_V64u", descriptor->microarchitecture);
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V64uV32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64uV32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32fV32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, const Yep32f *YEP_RESTRICT, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32fV32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f maximumArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f maximumInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f maximumRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32fV32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep32f); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(maximumArray); i++) {
								const Yep32f ulpError = yepBuiltin_Abs_32f_32f(maximumRefArray[i] - maximumArray[i]) / yepBuiltin_Ulp_32f_32f(maximumRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Max_V32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(maximumArray); i++) {
								const Yep32f ulpError = yepBuiltin_Abs_32f_32f(maximumRefArray[i] - maximumArray[i]) / yepBuiltin_Ulp_32f_32f(maximumRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Max_V32fV32f_V32f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V32fV32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32fV32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64fV64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, const Yep64f *YEP_RESTRICT, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64fV64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f maximumArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f maximumInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f maximumRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64fV64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep64f); maximumOffset++) {
						for (YepSize length = 0; length < 64; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(maximumArray); i++) {
								const Yep64f ulpError = yepBuiltin_Abs_64f_64f(maximumRefArray[i] - maximumArray[i]) / yepBuiltin_Ulp_64f_64f(maximumRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Max_V64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
						for (YepSize length = 1024; length < 1088; length += 1) {
							memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
							status = defaultImplementation(&xArray[xOffset], &yArray[yOffset], &maximumRefArray[maximumOffset], length);
							assert(status == YepStatusOk);

							memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
							status = descriptor->function(&xArray[xOffset], &yArray[yOffset], &maximumArray[maximumOffset], length);
							assert(status == YepStatusOk);

							for (YepSize i = 0; i < YEP_COUNT_OF(maximumArray); i++) {
								const Yep64f ulpError = yepBuiltin_Abs_64f_64f(maximumRefArray[i] - maximumArray[i]) / yepBuiltin_Ulp_64f_64f(maximumRefArray[i]);
								if (ulpError > 5.0) {
									failedTests += 1;
									reportFailedTest("yepCore_Max_V64fV64f_V64f", descriptor->microarchitecture, float(ulpError));
									goto next_descriptor;
								}
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V64fV64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64fV64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V8sS8s_V8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8s *YEP_RESTRICT, Yep8s, Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V8sS8s_V8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;
	YEP_ALIGN(64) Yep8s maximumArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s maximumInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s maximumRefArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V8sS8s_V8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep8s); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V8sS8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V8sS8s_V8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V8sS8s_V8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V8sS8s_V8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V8uS8u_V8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep8u *YEP_RESTRICT, Yep8u, Yep8u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V8uS8u_V8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	Yep8u y;
	YEP_ALIGN(64) Yep8u maximumArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u maximumInitArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u maximumRefArray[1088 + (64 / sizeof(Yep8u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V8uS8u_V8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep8u); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V8uS8u_V8u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V8uS8u_V8u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V8uS8u_V8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V8uS8u_V8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V16sS16s_V16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16s *YEP_RESTRICT, Yep16s, Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V16sS16s_V16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;
	YEP_ALIGN(64) Yep16s maximumArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s maximumInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s maximumRefArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V16sS16s_V16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep16s); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V16sS16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V16sS16s_V16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V16sS16s_V16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V16sS16s_V16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V16uS16u_V16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep16u *YEP_RESTRICT, Yep16u, Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V16uS16u_V16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	Yep16u y;
	YEP_ALIGN(64) Yep16u maximumArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u maximumInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u maximumRefArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V16uS16u_V16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep16u); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V16uS16u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V16uS16u_V16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V16uS16u_V16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V16uS16u_V16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32sS32s_V32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32s *YEP_RESTRICT, Yep32s, Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32sS32s_V32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;
	YEP_ALIGN(64) Yep32s maximumArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s maximumInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s maximumRefArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32sS32s_V32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep32s); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V32sS32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V32sS32s_V32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V32sS32s_V32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32sS32s_V32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32uS32u_V32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32u *YEP_RESTRICT, Yep32u, Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32uS32u_V32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	Yep32u y;
	YEP_ALIGN(64) Yep32u maximumArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u maximumInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u maximumRefArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32uS32u_V32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep32u); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V32uS32u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V32uS32u_V32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V32uS32u_V32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32uS32u_V32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64sS32s_V64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64s *YEP_RESTRICT, Yep32s, Yep64s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64sS32s_V64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	Yep32s y;
	YEP_ALIGN(64) Yep64s maximumArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s maximumInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s maximumRefArray[1088 + (64 / sizeof(Yep64s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64sS32s_V64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep64s); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V64sS32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V64sS32s_V64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V64sS32s_V64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64sS32s_V64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64uS32u_V64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64u *YEP_RESTRICT, Yep32u, Yep64u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64uS32u_V64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u xArray[1088 + (64 / sizeof(Yep64u))];
	Yep32u y;
	YEP_ALIGN(64) Yep64u maximumArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u maximumInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u maximumRefArray[1088 + (64 / sizeof(Yep64u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64uS32u_V64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64u); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep64u); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V64uS32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(maximumArray, maximumRefArray, sizeof(maximumArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_V64uS32u_V64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V64uS32u_V64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64uS32u_V64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V32fS32f_V32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep32f *YEP_RESTRICT, Yep32f, Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V32fS32f_V32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f y;
	YEP_ALIGN(64) Yep32f maximumArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f maximumInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f maximumRefArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V32fS32f_V32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep32f); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(maximumArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(maximumRefArray[i] - maximumArray[i]) / yepBuiltin_Ulp_32f_32f(maximumRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V32fS32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(maximumArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(maximumRefArray[i] - maximumArray[i]) / yepBuiltin_Ulp_32f_32f(maximumRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V32fS32f_V32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V32fS32f_V32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V32fS32f_V32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_V64fS64f_V64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(const Yep64f *YEP_RESTRICT, Yep64f, Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_V64fS64f_V64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f y;
	YEP_ALIGN(64) Yep64f maximumArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f maximumInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f maximumRefArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xArray, YEP_COUNT_OF(xArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &y, 1);
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, maximumInitArray, YEP_COUNT_OF(maximumInitArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_V64fS64f_V64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize maximumOffset = 0; maximumOffset < 64 / sizeof(Yep64f); maximumOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(maximumArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(maximumRefArray[i] - maximumArray[i]) / yepBuiltin_Ulp_64f_64f(maximumRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V64fS64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(maximumRefArray, maximumInitArray, sizeof(maximumRefArray));
						status = defaultImplementation(&xArray[xOffset], y, &maximumRefArray[maximumOffset], length);
						assert(status == YepStatusOk);

						memcpy(maximumArray, maximumInitArray, sizeof(maximumArray));
						status = descriptor->function(&xArray[xOffset], y, &maximumArray[maximumOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(maximumArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(maximumRefArray[i] - maximumArray[i]) / yepBuiltin_Ulp_64f_64f(maximumRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_V64fS64f_V64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_V64fS64f_V64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_V64fS64f_V64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV8sV8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s *YEP_RESTRICT, const Yep8s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV8sV8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xRefArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s yArray[1088 + (64 / sizeof(Yep8s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV8sV8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV8sV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV8sV8s_IV8s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV8sV8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV8sV8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV8uV8u_IV8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8u *YEP_RESTRICT, const Yep8u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV8uV8u_IV8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u xInitArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u xRefArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u yArray[1088 + (64 / sizeof(Yep8u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV8uV8u_IV8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep8u); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV8uV8u_IV8u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV8uV8u_IV8u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV8uV8u_IV8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV8uV8u_IV8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV16sV16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s *YEP_RESTRICT, const Yep16s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV16sV16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xRefArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s yArray[1088 + (64 / sizeof(Yep16s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV16sV16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV16sV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV16sV16s_IV16s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV16sV16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV16sV16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV16uV16u_IV16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16u *YEP_RESTRICT, const Yep16u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV16uV16u_IV16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u xInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u xRefArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u yArray[1088 + (64 / sizeof(Yep16u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV16uV16u_IV16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep16u); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV16uV16u_IV16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV16uV16u_IV16u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV16uV16u_IV16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV16uV16u_IV16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV32sV32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV32sV32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xRefArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV32sV32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV32sV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV32sV32s_IV32s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV32sV32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV32sV32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV32uV32u_IV32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV32uV32u_IV32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u xInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u xRefArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV32uV32u_IV32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV32uV32u_IV32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV32uV32u_IV32u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV32uV32u_IV32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV32uV32u_IV32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV64sV32s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s *YEP_RESTRICT, const Yep32s *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV64sV32s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xRefArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep32s yArray[1088 + (64 / sizeof(Yep32s))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV64sV32s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32s); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV64sV32s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV64sV32s_IV64s", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV64sV32s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV64sV32s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV64uV32u_IV64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64u *YEP_RESTRICT, const Yep32u *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV64uV32u_IV64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u xArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u xInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u xRefArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep32u yArray[1088 + (64 / sizeof(Yep32u))];

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV64uV32u_IV64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64u); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32u); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV64uV32u_IV64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV64uV32u_IV64u", descriptor->microarchitecture);
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV64uV32u_IV64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV64uV32u_IV64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV32fV32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f *YEP_RESTRICT, const Yep32f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV32fV32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xRefArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f yArray[1088 + (64 / sizeof(Yep32f))];

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV32fV32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep32f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_IV32fV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_IV32fV32f_IV32f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV32fV32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV32fV32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV64fV64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f *YEP_RESTRICT, const Yep64f *YEP_RESTRICT, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV64fV64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xRefArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f yArray[1088 + (64 / sizeof(Yep64f))];

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, yArray, YEP_COUNT_OF(yArray));
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV64fV64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize yOffset = 0; yOffset < 64 / sizeof(Yep64f); yOffset++) {
					for (YepSize length = 0; length < 64; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_IV64fV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
					for (YepSize length = 1024; length < 1088; length += 1) {
						memcpy(xRefArray, xInitArray, sizeof(xRefArray));
						status = defaultImplementation(&xRefArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						memcpy(xArray, xInitArray, sizeof(xArray));
						status = descriptor->function(&xArray[xOffset], &yArray[yOffset], length);
						assert(status == YepStatusOk);

						for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
							const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
							if (ulpError > 5.0) {
								failedTests += 1;
								reportFailedTest("yepCore_Max_IV64fV64f_IV64f", descriptor->microarchitecture, float(ulpError));
								goto next_descriptor;
							}
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV64fV64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV64fV64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV8sS8s_IV8s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8s *YEP_RESTRICT, Yep8s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV8sS8s_IV8s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8s xArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xInitArray[1088 + (64 / sizeof(Yep8s))];
	YEP_ALIGN(64) Yep8s xRefArray[1088 + (64 / sizeof(Yep8s))];
	Yep8s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8sS8s_V8s(&rng, -128, 127, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV8sS8s_IV8s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV8sS8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV8sS8s_IV8s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_IV8sS8s_IV8s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV8sS8s_IV8s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV8uS8u_IV8u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep8u *YEP_RESTRICT, Yep8u, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV8uS8u_IV8u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep8u xArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u xInitArray[1088 + (64 / sizeof(Yep8u))];
	YEP_ALIGN(64) Yep8u xRefArray[1088 + (64 / sizeof(Yep8u))];
	Yep8u y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S8uS8u_V8u(&rng, 0u, 255u, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV8uS8u_IV8u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep8u); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV8uS8u_IV8u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV8uS8u_IV8u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_IV8uS8u_IV8u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV8uS8u_IV8u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV16sS16s_IV16s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16s *YEP_RESTRICT, Yep16s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV16sS16s_IV16s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16s xArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xInitArray[1088 + (64 / sizeof(Yep16s))];
	YEP_ALIGN(64) Yep16s xRefArray[1088 + (64 / sizeof(Yep16s))];
	Yep16s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16sS16s_V16s(&rng, -32768, 32767, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV16sS16s_IV16s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV16sS16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV16sS16s_IV16s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_IV16sS16s_IV16s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV16sS16s_IV16s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV16uS16u_IV16u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep16u *YEP_RESTRICT, Yep16u, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV16uS16u_IV16u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep16u xArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u xInitArray[1088 + (64 / sizeof(Yep16u))];
	YEP_ALIGN(64) Yep16u xRefArray[1088 + (64 / sizeof(Yep16u))];
	Yep16u y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S16uS16u_V16u(&rng, 0u, 65535u, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV16uS16u_IV16u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep16u); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV16uS16u_IV16u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV16uS16u_IV16u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_IV16uS16u_IV16u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV16uS16u_IV16u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV32sS32s_IV32s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32s *YEP_RESTRICT, Yep32s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV32sS32s_IV32s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32s xArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xInitArray[1088 + (64 / sizeof(Yep32s))];
	YEP_ALIGN(64) Yep32s xRefArray[1088 + (64 / sizeof(Yep32s))];
	Yep32s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV32sS32s_IV32s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV32sS32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV32sS32s_IV32s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_IV32sS32s_IV32s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV32sS32s_IV32s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV32uS32u_IV32u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32u *YEP_RESTRICT, Yep32u, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV32uS32u_IV32u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32u xArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u xInitArray[1088 + (64 / sizeof(Yep32u))];
	YEP_ALIGN(64) Yep32u xRefArray[1088 + (64 / sizeof(Yep32u))];
	Yep32u y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV32uS32u_IV32u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32u); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV32uS32u_IV32u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV32uS32u_IV32u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_IV32uS32u_IV32u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV32uS32u_IV32u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV64sS32s_IV64s(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64s *YEP_RESTRICT, Yep32s, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV64sS32s_IV64s);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64s xArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xInitArray[1088 + (64 / sizeof(Yep64s))];
	YEP_ALIGN(64) Yep64s xRefArray[1088 + (64 / sizeof(Yep64s))];
	Yep32s y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64sS64s_V64s(&rng, -9223372036854775808ll, 9223372036854775807ll, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32sS32s_V32s(&rng, -2147483648, 2147483647, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV64sS32s_IV64s[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64s); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV64sS32s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV64sS32s_IV64s", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_IV64sS32s_IV64s", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV64sS32s_IV64s", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV64uS32u_IV64u(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64u *YEP_RESTRICT, Yep32u, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV64uS32u_IV64u);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64u xArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u xInitArray[1088 + (64 / sizeof(Yep64u))];
	YEP_ALIGN(64) Yep64u xRefArray[1088 + (64 / sizeof(Yep64u))];
	Yep32u y;

	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S64uS64u_V64u(&rng, 0ull, 18446744073709551615ull, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateDiscreteUniform_S32uS32u_V32u(&rng, 0u, 4294967295u, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV64uS32u_IV64u[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64u); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV64uS32u_IV64u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					if (memcmp(xArray, xRefArray, sizeof(xArray)) != 0) {
						failedTests += 1;
						reportFailedTest("yepCore_Max_IV64uS32u_IV64u", descriptor->microarchitecture);
						goto next_descriptor;
					}
				}
			}
			reportPassedTest("yepCore_Max_IV64uS32u_IV64u", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV64uS32u_IV64u", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV32fS32f_IV32f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep32f *YEP_RESTRICT, Yep32f, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV32fS32f_IV32f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep32f xArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xInitArray[1088 + (64 / sizeof(Yep32f))];
	YEP_ALIGN(64) Yep32f xRefArray[1088 + (64 / sizeof(Yep32f))];
	Yep32f y;

	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S32fS32f_V32f_Acc32(&rng, -1.0f, 1.0f, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV32fS32f_IV32f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep32f); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV32fS32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep32f ulpError = yepBuiltin_Abs_32f_32f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_32f_32f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV32fS32f_IV32f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV32fS32f_IV32f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV32fS32f_IV32f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

static Yep32s Test_Max_IV64fS64f_IV64f(Yep64u supportedIsaFeatures, Yep64u supportedSimdFeatures, Yep64u supportedSystemFeatures) {
	YepRandom_WELL1024a rng;
	YepStatus status = yepRandom_WELL1024a_Init(&rng);
	assert(status == YepStatusOk);

	typedef YepStatus (YEPABI* FunctionPointer)(Yep64f *YEP_RESTRICT, Yep64f, YepSize);
	typedef const FunctionDescriptor<FunctionPointer>* DescriptorPointer;
	const DescriptorPointer defaultDescriptor = findDefaultDescriptor(_dispatchTable_yepCore_Max_IV64fS64f_IV64f);
	const FunctionPointer defaultImplementation = defaultDescriptor->function;
	Yep32s failedTests = 0;

	YEP_ALIGN(64) Yep64f xArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xInitArray[1088 + (64 / sizeof(Yep64f))];
	YEP_ALIGN(64) Yep64f xRefArray[1088 + (64 / sizeof(Yep64f))];
	Yep64f y;

	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, xInitArray, YEP_COUNT_OF(xInitArray));
	assert(status == YepStatusOk);
	status = yepRandom_WELL1024a_GenerateUniform_S64fS64f_V64f_Acc64(&rng, -1.0, 1.0, &y, 1);
	assert(status == YepStatusOk);

	for (DescriptorPointer descriptor = &_dispatchTable_yepCore_Max_IV64fS64f_IV64f[0]; descriptor != defaultDescriptor; descriptor++) {
		const Yep64u unsupportedRequiredFeatures = (descriptor->isaFeatures & ~supportedIsaFeatures) |
			(descriptor->simdFeatures & ~supportedSimdFeatures) |
			(descriptor->systemFeatures & ~supportedSystemFeatures);
		if (unsupportedRequiredFeatures == 0) {
			for (YepSize xOffset = 0; xOffset < 64 / sizeof(Yep64f); xOffset++) {
				for (YepSize length = 0; length < 64; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV64fS64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
				for (YepSize length = 1024; length < 1088; length += 1) {
					memcpy(xRefArray, xInitArray, sizeof(xRefArray));
					status = defaultImplementation(&xRefArray[xOffset], y, length);
					assert(status == YepStatusOk);

					memcpy(xArray, xInitArray, sizeof(xArray));
					status = descriptor->function(&xArray[xOffset], y, length);
					assert(status == YepStatusOk);

					for (YepSize i = 0; i < YEP_COUNT_OF(xArray); i++) {
						const Yep64f ulpError = yepBuiltin_Abs_64f_64f(xRefArray[i] - xArray[i]) / yepBuiltin_Ulp_64f_64f(xRefArray[i]);
						if (ulpError > 5.0) {
							failedTests += 1;
							reportFailedTest("yepCore_Max_IV64fS64f_IV64f", descriptor->microarchitecture, float(ulpError));
							goto next_descriptor;
						}
					}
				}
			}
			reportPassedTest("yepCore_Max_IV64fS64f_IV64f", descriptor->microarchitecture);
		} else {
			reportSkippedTest("yepCore_Max_IV64fS64f_IV64f", descriptor->microarchitecture);
		}
next_descriptor:
		continue;
	}
	return -failedTests;
}

int main(int argc, char** argv) {
	YepBoolean testMax_V8s_S8s = YepBooleanFalse;
	YepBoolean testMax_V8u_S8u = YepBooleanFalse;
	YepBoolean testMax_V16s_S16s = YepBooleanFalse;
	YepBoolean testMax_V16u_S16u = YepBooleanFalse;
	YepBoolean testMax_V32s_S32s = YepBooleanFalse;
	YepBoolean testMax_V32u_S32u = YepBooleanFalse;
	YepBoolean testMax_V64s_S64s = YepBooleanFalse;
	YepBoolean testMax_V64u_S64u = YepBooleanFalse;
	YepBoolean testMax_V32f_S32f = YepBooleanFalse;
	YepBoolean testMax_V64f_S64f = YepBooleanFalse;
	YepBoolean testMax_V8sV8s_V8s = YepBooleanFalse;
	YepBoolean testMax_V8uV8u_V8u = YepBooleanFalse;
	YepBoolean testMax_V16sV16s_V16s = YepBooleanFalse;
	YepBoolean testMax_V16uV16u_V16u = YepBooleanFalse;
	YepBoolean testMax_V32sV32s_V32s = YepBooleanFalse;
	YepBoolean testMax_V32uV32u_V32u = YepBooleanFalse;
	YepBoolean testMax_V64sV32s_V64s = YepBooleanFalse;
	YepBoolean testMax_V64uV32u_V64u = YepBooleanFalse;
	YepBoolean testMax_V32fV32f_V32f = YepBooleanFalse;
	YepBoolean testMax_V64fV64f_V64f = YepBooleanFalse;
	YepBoolean testMax_V8sS8s_V8s = YepBooleanFalse;
	YepBoolean testMax_V8uS8u_V8u = YepBooleanFalse;
	YepBoolean testMax_V16sS16s_V16s = YepBooleanFalse;
	YepBoolean testMax_V16uS16u_V16u = YepBooleanFalse;
	YepBoolean testMax_V32sS32s_V32s = YepBooleanFalse;
	YepBoolean testMax_V32uS32u_V32u = YepBooleanFalse;
	YepBoolean testMax_V64sS32s_V64s = YepBooleanFalse;
	YepBoolean testMax_V64uS32u_V64u = YepBooleanFalse;
	YepBoolean testMax_V32fS32f_V32f = YepBooleanFalse;
	YepBoolean testMax_V64fS64f_V64f = YepBooleanFalse;
	YepBoolean testMax_IV8sV8s_IV8s = YepBooleanFalse;
	YepBoolean testMax_IV8uV8u_IV8u = YepBooleanFalse;
	YepBoolean testMax_IV16sV16s_IV16s = YepBooleanFalse;
	YepBoolean testMax_IV16uV16u_IV16u = YepBooleanFalse;
	YepBoolean testMax_IV32sV32s_IV32s = YepBooleanFalse;
	YepBoolean testMax_IV32uV32u_IV32u = YepBooleanFalse;
	YepBoolean testMax_IV64sV32s_IV64s = YepBooleanFalse;
	YepBoolean testMax_IV64uV32u_IV64u = YepBooleanFalse;
	YepBoolean testMax_IV32fV32f_IV32f = YepBooleanFalse;
	YepBoolean testMax_IV64fV64f_IV64f = YepBooleanFalse;
	YepBoolean testMax_IV8sS8s_IV8s = YepBooleanFalse;
	YepBoolean testMax_IV8uS8u_IV8u = YepBooleanFalse;
	YepBoolean testMax_IV16sS16s_IV16s = YepBooleanFalse;
	YepBoolean testMax_IV16uS16u_IV16u = YepBooleanFalse;
	YepBoolean testMax_IV32sS32s_IV32s = YepBooleanFalse;
	YepBoolean testMax_IV32uS32u_IV32u = YepBooleanFalse;
	YepBoolean testMax_IV64sS32s_IV64s = YepBooleanFalse;
	YepBoolean testMax_IV64uS32u_IV64u = YepBooleanFalse;
	YepBoolean testMax_IV32fS32f_IV32f = YepBooleanFalse;
	YepBoolean testMax_IV64fS64f_IV64f = YepBooleanFalse;
	if (argc == 1) {
		/* No tests specified: run all tests*/
		testMax_V8s_S8s = YepBooleanTrue;
		testMax_V8u_S8u = YepBooleanTrue;
		testMax_V16s_S16s = YepBooleanTrue;
		testMax_V16u_S16u = YepBooleanTrue;
		testMax_V32s_S32s = YepBooleanTrue;
		testMax_V32u_S32u = YepBooleanTrue;
		testMax_V64s_S64s = YepBooleanTrue;
		testMax_V64u_S64u = YepBooleanTrue;
		testMax_V32f_S32f = YepBooleanTrue;
		testMax_V64f_S64f = YepBooleanTrue;
		testMax_V8sV8s_V8s = YepBooleanTrue;
		testMax_V8uV8u_V8u = YepBooleanTrue;
		testMax_V16sV16s_V16s = YepBooleanTrue;
		testMax_V16uV16u_V16u = YepBooleanTrue;
		testMax_V32sV32s_V32s = YepBooleanTrue;
		testMax_V32uV32u_V32u = YepBooleanTrue;
		testMax_V64sV32s_V64s = YepBooleanTrue;
		testMax_V64uV32u_V64u = YepBooleanTrue;
		testMax_V32fV32f_V32f = YepBooleanTrue;
		testMax_V64fV64f_V64f = YepBooleanTrue;
		testMax_V8sS8s_V8s = YepBooleanTrue;
		testMax_V8uS8u_V8u = YepBooleanTrue;
		testMax_V16sS16s_V16s = YepBooleanTrue;
		testMax_V16uS16u_V16u = YepBooleanTrue;
		testMax_V32sS32s_V32s = YepBooleanTrue;
		testMax_V32uS32u_V32u = YepBooleanTrue;
		testMax_V64sS32s_V64s = YepBooleanTrue;
		testMax_V64uS32u_V64u = YepBooleanTrue;
		testMax_V32fS32f_V32f = YepBooleanTrue;
		testMax_V64fS64f_V64f = YepBooleanTrue;
		testMax_IV8sV8s_IV8s = YepBooleanTrue;
		testMax_IV8uV8u_IV8u = YepBooleanTrue;
		testMax_IV16sV16s_IV16s = YepBooleanTrue;
		testMax_IV16uV16u_IV16u = YepBooleanTrue;
		testMax_IV32sV32s_IV32s = YepBooleanTrue;
		testMax_IV32uV32u_IV32u = YepBooleanTrue;
		testMax_IV64sV32s_IV64s = YepBooleanTrue;
		testMax_IV64uV32u_IV64u = YepBooleanTrue;
		testMax_IV32fV32f_IV32f = YepBooleanTrue;
		testMax_IV64fV64f_IV64f = YepBooleanTrue;
		testMax_IV8sS8s_IV8s = YepBooleanTrue;
		testMax_IV8uS8u_IV8u = YepBooleanTrue;
		testMax_IV16sS16s_IV16s = YepBooleanTrue;
		testMax_IV16uS16u_IV16u = YepBooleanTrue;
		testMax_IV32sS32s_IV32s = YepBooleanTrue;
		testMax_IV32uS32u_IV32u = YepBooleanTrue;
		testMax_IV64sS32s_IV64s = YepBooleanTrue;
		testMax_IV64uS32u_IV64u = YepBooleanTrue;
		testMax_IV32fS32f_IV32f = YepBooleanTrue;
		testMax_IV64fS64f_IV64f = YepBooleanTrue;
	} else {
		/* Some tests specified: run only specified tests*/
		for (int i = 1; i < argc; i++) {
			if (strcmp(argv[i], "V8s_S8s") == 0) {
				testMax_V8s_S8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8u_S8u") == 0) {
				testMax_V8u_S8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16s_S16s") == 0) {
				testMax_V16s_S16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16u_S16u") == 0) {
				testMax_V16u_S16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32s_S32s") == 0) {
				testMax_V32s_S32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32u_S32u") == 0) {
				testMax_V32u_S32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64s_S64s") == 0) {
				testMax_V64s_S64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64u_S64u") == 0) {
				testMax_V64u_S64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32f_S32f") == 0) {
				testMax_V32f_S32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64f_S64f") == 0) {
				testMax_V64f_S64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sV8s_V8s") == 0) {
				testMax_V8sV8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8uV8u_V8u") == 0) {
				testMax_V8uV8u_V8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sV16s_V16s") == 0) {
				testMax_V16sV16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16uV16u_V16u") == 0) {
				testMax_V16uV16u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sV32s_V32s") == 0) {
				testMax_V32sV32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32uV32u_V32u") == 0) {
				testMax_V32uV32u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sV32s_V64s") == 0) {
				testMax_V64sV32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64uV32u_V64u") == 0) {
				testMax_V64uV32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fV32f_V32f") == 0) {
				testMax_V32fV32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fV64f_V64f") == 0) {
				testMax_V64fV64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8sS8s_V8s") == 0) {
				testMax_V8sS8s_V8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V8uS8u_V8u") == 0) {
				testMax_V8uS8u_V8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16sS16s_V16s") == 0) {
				testMax_V16sS16s_V16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V16uS16u_V16u") == 0) {
				testMax_V16uS16u_V16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32sS32s_V32s") == 0) {
				testMax_V32sS32s_V32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32uS32u_V32u") == 0) {
				testMax_V32uS32u_V32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64sS32s_V64s") == 0) {
				testMax_V64sS32s_V64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64uS32u_V64u") == 0) {
				testMax_V64uS32u_V64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "V32fS32f_V32f") == 0) {
				testMax_V32fS32f_V32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "V64fS64f_V64f") == 0) {
				testMax_V64fS64f_V64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8sV8s_IV8s") == 0) {
				testMax_IV8sV8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8uV8u_IV8u") == 0) {
				testMax_IV8uV8u_IV8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16sV16s_IV16s") == 0) {
				testMax_IV16sV16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16uV16u_IV16u") == 0) {
				testMax_IV16uV16u_IV16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32sV32s_IV32s") == 0) {
				testMax_IV32sV32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32uV32u_IV32u") == 0) {
				testMax_IV32uV32u_IV32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64sV32s_IV64s") == 0) {
				testMax_IV64sV32s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64uV32u_IV64u") == 0) {
				testMax_IV64uV32u_IV64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32fV32f_IV32f") == 0) {
				testMax_IV32fV32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64fV64f_IV64f") == 0) {
				testMax_IV64fV64f_IV64f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8sS8s_IV8s") == 0) {
				testMax_IV8sS8s_IV8s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV8uS8u_IV8u") == 0) {
				testMax_IV8uS8u_IV8u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16sS16s_IV16s") == 0) {
				testMax_IV16sS16s_IV16s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV16uS16u_IV16u") == 0) {
				testMax_IV16uS16u_IV16u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32sS32s_IV32s") == 0) {
				testMax_IV32sS32s_IV32s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32uS32u_IV32u") == 0) {
				testMax_IV32uS32u_IV32u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64sS32s_IV64s") == 0) {
				testMax_IV64sS32s_IV64s = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64uS32u_IV64u") == 0) {
				testMax_IV64uS32u_IV64u = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV32fS32f_IV32f") == 0) {
				testMax_IV32fS32f_IV32f = YepBooleanTrue;
			} else if (strcmp(argv[i], "IV64fS64f_IV64f") == 0) {
				testMax_IV64fS64f_IV64f = YepBooleanTrue;
			} else {
				fprintf(stderr, "Unknown function name \"%s\"", argv[i]);
				return 1;
			}
		}
	}
	YepStatus status = _yepLibrary_InitCpuInfo();
	assert(status == YepStatusOk);

	Yep64u supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures;
	status = yepLibrary_GetCpuIsaFeatures(&supportedIsaFeatures);
	assert(status == YepStatusOk);
	status = yepLibrary_GetCpuSimdFeatures(&supportedSimdFeatures);
	assert(status == YepStatusOk);
	status = yepLibrary_GetCpuSystemFeatures(&supportedSystemFeatures);
	assert(status == YepStatusOk);

	Yep32s failedTests = 0;
	if YEP_LIKELY(testMax_V8s_S8s)
		failedTests += Test_Max_V8s_S8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V8u_S8u)
		failedTests += Test_Max_V8u_S8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V16s_S16s)
		failedTests += Test_Max_V16s_S16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V16u_S16u)
		failedTests += Test_Max_V16u_S16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32s_S32s)
		failedTests += Test_Max_V32s_S32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32u_S32u)
		failedTests += Test_Max_V32u_S32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64s_S64s)
		failedTests += Test_Max_V64s_S64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64u_S64u)
		failedTests += Test_Max_V64u_S64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32f_S32f)
		failedTests += Test_Max_V32f_S32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64f_S64f)
		failedTests += Test_Max_V64f_S64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V8sV8s_V8s)
		failedTests += Test_Max_V8sV8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V8uV8u_V8u)
		failedTests += Test_Max_V8uV8u_V8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V16sV16s_V16s)
		failedTests += Test_Max_V16sV16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V16uV16u_V16u)
		failedTests += Test_Max_V16uV16u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32sV32s_V32s)
		failedTests += Test_Max_V32sV32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32uV32u_V32u)
		failedTests += Test_Max_V32uV32u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64sV32s_V64s)
		failedTests += Test_Max_V64sV32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64uV32u_V64u)
		failedTests += Test_Max_V64uV32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32fV32f_V32f)
		failedTests += Test_Max_V32fV32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64fV64f_V64f)
		failedTests += Test_Max_V64fV64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V8sS8s_V8s)
		failedTests += Test_Max_V8sS8s_V8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V8uS8u_V8u)
		failedTests += Test_Max_V8uS8u_V8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V16sS16s_V16s)
		failedTests += Test_Max_V16sS16s_V16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V16uS16u_V16u)
		failedTests += Test_Max_V16uS16u_V16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32sS32s_V32s)
		failedTests += Test_Max_V32sS32s_V32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32uS32u_V32u)
		failedTests += Test_Max_V32uS32u_V32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64sS32s_V64s)
		failedTests += Test_Max_V64sS32s_V64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64uS32u_V64u)
		failedTests += Test_Max_V64uS32u_V64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V32fS32f_V32f)
		failedTests += Test_Max_V32fS32f_V32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_V64fS64f_V64f)
		failedTests += Test_Max_V64fS64f_V64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV8sV8s_IV8s)
		failedTests += Test_Max_IV8sV8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV8uV8u_IV8u)
		failedTests += Test_Max_IV8uV8u_IV8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV16sV16s_IV16s)
		failedTests += Test_Max_IV16sV16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV16uV16u_IV16u)
		failedTests += Test_Max_IV16uV16u_IV16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV32sV32s_IV32s)
		failedTests += Test_Max_IV32sV32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV32uV32u_IV32u)
		failedTests += Test_Max_IV32uV32u_IV32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV64sV32s_IV64s)
		failedTests += Test_Max_IV64sV32s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV64uV32u_IV64u)
		failedTests += Test_Max_IV64uV32u_IV64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV32fV32f_IV32f)
		failedTests += Test_Max_IV32fV32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV64fV64f_IV64f)
		failedTests += Test_Max_IV64fV64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV8sS8s_IV8s)
		failedTests += Test_Max_IV8sS8s_IV8s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV8uS8u_IV8u)
		failedTests += Test_Max_IV8uS8u_IV8u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV16sS16s_IV16s)
		failedTests += Test_Max_IV16sS16s_IV16s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV16uS16u_IV16u)
		failedTests += Test_Max_IV16uS16u_IV16u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV32sS32s_IV32s)
		failedTests += Test_Max_IV32sS32s_IV32s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV32uS32u_IV32u)
		failedTests += Test_Max_IV32uS32u_IV32u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV64sS32s_IV64s)
		failedTests += Test_Max_IV64sS32s_IV64s(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV64uS32u_IV64u)
		failedTests += Test_Max_IV64uS32u_IV64u(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV32fS32f_IV32f)
		failedTests += Test_Max_IV32fS32f_IV32f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	if YEP_LIKELY(testMax_IV64fS64f_IV64f)
		failedTests += Test_Max_IV64fS64f_IV64f(supportedIsaFeatures, supportedSimdFeatures, supportedSystemFeatures);
	return failedTests;
}
